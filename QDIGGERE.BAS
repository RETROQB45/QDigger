DECLARE SUB ADD (obj%, cx%, cy%)
DECLARE SUB ADDSCORE (amount%)
DECLARE SUB ANIMATE (x%, y%, p AS ANY, redr%)
DECLARE FUNCTION BOXCOLL% (x%, y%, w%, h%, ax%, ay%, aw%, ah%)
DECLARE FUNCTION CHECKBAGSHIFT% (x%, y%, dir%)
DECLARE SUB CHECKBONUS (x%, y%, scoreflag%)
DECLARE SUB CHECKEMERALDS (plx%, ply%, scoreflag%)
DECLARE SUB CHECKGOLD (plx%, ply%, scoreflag%)
DECLARE SUB CHECKKILL ()
DECLARE SUB CHECKNEWHISCORE (score AS LONG, gameresult%)
DECLARE SUB CLOSELEVEL ()
DECLARE SUB COLLAPSE ()
DECLARE SUB DELAY (sec!)
DECLARE SUB DRAWHOLE (x%, y%)
DECLARE SUB DRAWIMG (x%, y%, imgn%, disablemask%)
DECLARE SUB DRAWMAP ()
DECLARE SUB DRAWPIC (x%, y%, p AS ANY, disablemask%)
DECLARE SUB ERASEIMG (x%, y%, im%)
DECLARE SUB ERASEPIC (x%, y%, p AS ANY)
DECLARE SUB FILLBGR (num%)
DECLARE SUB FILLMAZECELL (x%, y%, i%, l%, r%, u%, d%)
DECLARE SUB GETCELLCOORDS (x%, y%, rx%, ry%)
DECLARE SUB GETIMAGE (i%, x%, y%, idx%)
DECLARE SUB GETINPUTS ()
DECLARE FUNCTION GETLEVIDX$ (num%)
DECLARE SUB GETMAZECELL (x%, y%, rx%, ry%)
DECLARE FUNCTION GETPATH% (sx%, sy%, tx%, ty%, pl%)
DECLARE SUB GETRANDOMCELL (dx%, dy%)
DECLARE FUNCTION IMGSIZE% (w%, h%)
DECLARE SUB INIT ()
DECLARE SUB INITDIGGER ()
DECLARE SUB LOADGRAPHICS ()
DECLARE SUB LOADIMAGE (w%, h%, index%)
DECLARE SUB LOADLEVEL (levidx AS INTEGER)
DECLARE SUB LOADLEVIDX ()
DECLARE SUB LOADSCORES (file$, scorebuf() AS ANY)
DECLARE SUB MOVEBAGS ()
DECLARE SUB MOVEDIGGER (dx%, dy%)
DECLARE SUB MOVEENEMIES ()
DECLARE SUB MOVEEYE ()
DECLARE SUB MOVEGOLD ()
DECLARE SUB NEWGAME ()
DECLARE SUB NEXTLEVEL ()
DECLARE FUNCTION NUMTOSTR$ (n AS LONG)
DECLARE FUNCTION OPENLEVEL% (idx$)
DECLARE SUB QUIT ()
DECLARE FUNCTION READLEVELSTR$ ()
DECLARE SUB REDRAW (x%, y%, obj() AS ANY, objc%)
DECLARE SUB REDRAWOBJS (arr() AS ANY, n%, maskfl%)
DECLARE FUNCTION RESTART% ()
DECLARE SUB RESTOREFIELD ()
DECLARE SUB RETRACE ()
DECLARE SUB SCANMAZECELL (cx%, cy%, inner%, lw%, rw%, uw%, dw%)
DECLARE SUB SCREENSHOT ()
DECLARE SUB SETPAL (palmode AS INTEGER)
DECLARE FUNCTION SHIFTBAG% (num%, dir%)
DECLARE SUB SHOOT (dx%, dy%)
DECLARE SUB SHOWHINT (col%, row%, a$)
DECLARE SUB SHOWHINTS ()
DECLARE SUB SHOWHISCORES ()
DECLARE SUB SHOWSCORE (score AS LONG, lives AS INTEGER)
DECLARE FUNCTION TEVENT% (t AS ANY)
DECLARE SUB UPDATESCORES ()
DEFINT A-Z

' options
CONST lifecost = 5000
CONST hiscorefile$ = "digger.sco"

' "system" constants
CONST FALSE = 0, TRUE = NOT FALSE, OLD = -2
CONST scrmode = 9, nopal = FALSE
CONST namelen = 14

'colors in colortable (change palette made easy)
CONST blackclr = 0
CONST greenclr = 2'1
CONST redclr = 4'2
CONST goldclr = 6'3
CONST grayclr = 7

TYPE SCORETYPE
	uname AS STRING * namelen
	score AS LONG
END TYPE
TYPE PICPAR
	mode  AS INTEGER
	frame AS INTEGER
END TYPE
TYPE TIMEINT
	starttime AS SINGLE
	interval  AS SINGLE
END TYPE
TYPE DIGGERTYPE
	x         AS INTEGER
	y         AS INTEGER
	startx    AS INTEGER
	starty    AS INTEGER
	dx        AS INTEGER
	dy        AS INTEGER
	pic       AS PICPAR
	mode      AS INTEGER
	eye       AS INTEGER
	lives     AS INTEGER
	score     AS LONG
	teye      AS TIMEINT
END TYPE
TYPE ENEMYTYPE
	x         AS INTEGER
	y         AS INTEGER
	stpx      AS INTEGER
	stpy      AS INTEGER
	trgx      AS INTEGER
	trgy      AS INTEGER
	dir       AS INTEGER
	pic       AS PICPAR
	chaseflee AS INTEGER
	mode      AS INTEGER
	thob      AS TIMEINT
	tdead     AS TIMEINT
END TYPE
TYPE NESTTYPE
	x       AS INTEGER
	y       AS INTEGER
	count   AS INTEGER
END TYPE
TYPE PICKUPTYPE
	x       AS INTEGER
	y       AS INTEGER
	mode    AS INTEGER
	pic     AS PICPAR
	use     AS INTEGER
	misc    AS INTEGER
	fally   AS INTEGER
	dx      AS INTEGER
	dy      AS INTEGER
	dir     AS INTEGER
	t       AS TIMEINT
END TYPE
TYPE BONUSTYPE
	x       AS INTEGER
	y       AS INTEGER
	use     AS INTEGER
	iwait   AS SINGLE
	ilen    AS SINGLE
	t       AS TIMEINT
END TYPE

'enemy states
CONST enm.creating = 1
CONST enm.nobbin = 2
CONST enm.hobbin = 3
CONST enm.dying = 4
CONST enm.dead = 5

' mazecell inner stats
CONST mz.filled = -1
CONST mz.empty = 0
CONST mz.half = 1
CONST mz.init = -100

CONST gr.winner = 1
CONST gr.gameover = 2
CONST gr.abort = 0

CONST hiscorec = 7
CONST scores.y = 8
CONST scores.x = 46

'ADD constants
CONST newemerald = 1
CONST newbag = 2
CONST newnobbin = 4
CONST newgold = 5

' palette modes
CONST pal.loading = -1
CONST pal.normal = 0
CONST pal.bonus = 1

' digger constants
CONST diggerspeedy = 3
CONST diggerspeedx = 4
CONST dgr.left = 1
CONST dgr.right = 2
CONST dgr.up = 3
CONST dgr.down = 4
CONST dgr.dead = 5
CONST dgr.falling = 6

' playing screen & maze properties
CONST viewx = 12, viewy = 8    ' from left&top of playing field
CONST cellw = 15 + 5 ' = 20    ' screen cell size
CONST cellh = 14 + 4 ' = 18
CONST mazex = 15               ' maze size
CONST mazey = 10

' game field size
CONST f.x = 10
CONST f.y = 16
CONST f.w = cellw * mazex + 20
CONST f.h = cellh * mazey + 12

' time intervals, their modification params, and extreme values
CONST tim.s.eye = 5
CONST tim.s.hobbin = 3
CONST tim.s.nobbin = 15
CONST tim.d.nobbin = -1
CONST tim.d.hobbin = 1
CONST tim.min.nobbin = 7
CONST tim.max.hobbin = 7

' animation indexes
CONST ani.stat = 0
CONST ani.bgrs = 1
CONST ani.dgrleft = 2
CONST ani.dgrright = 3
CONST ani.dgrup = 4
CONST ani.dgrdown = 5
CONST anid.withouteye = 4
CONST ani.dgrxleft = 6
CONST ani.dgrxright = 7
CONST ani.dgrxup = 8
CONST ani.dgrxdown = 9
CONST ani.dgrdie = 10
CONST ani.nobbin = 11
CONST ani.nobbindie = 12
CONST ani.hobbinleft = 13
CONST ani.hobbinright = 14
CONST ani.hobbindieleft = 15
CONST ani.hobbindieright = 16
CONST ani.emerald = 17
CONST ani.bag = 19
CONST ani.bagleft = 18
CONST ani.bagright = 20
CONST ani.bagfall = 21
CONST ani.bonus = 22
CONST ani.coins = 23
CONST ani.expl = 24
CONST ani.fire = 25
CONST ani.dig = 26
CONST iblob.down = 79
CONST iblob.left = iblob.down - 3
CONST iblob.right = iblob.down - 2
CONST iblob.up = iblob.down - 1

CONST img1 = 0
CONST framec = 1
CONST mask = 1
CONST pic = 0

CONST opened = 0
CONST leftwall = 1
CONST rightwall = 2
CONST upperwall = 4
CONST lowerwall = 8
CONST filled = 16

' bag movement modes
CONST bagm.normal = 0
CONST bagm.swinging = 1
CONST bagm.left = 2
CONST bagm.right = 3
CONST bagm.falling = 4

CONST maxcol = 15

CONST emerw = 14, emerh = 10
CONST goldw = 17, goldh = 15
CONST imgw = 16, imgh = 16

CONST gs.play = 0
CONST gs.pause = 1
CONST gs.killed = 2
CONST gs.restart = 3
CONST gs.newgame = 10
CONST gs.quit = 100

CONST eyem.normal = 0
CONST eyem.expl = 1
CONST eyew = 8, eyeh = 8

'$DYNAMIC
DIM SHARED mapon AS INTEGER
DIM SHARED eye AS PICKUPTYPE
DIM SHARED bonus AS BONUSTYPE
DIM SHARED tim.hobbin AS SINGLE, tim.nobbin AS SINGLE, tim.eye AS SINGLE
DIM SHARED maze(-1 TO mazex * 2 + 1, -1 TO mazey * 2 + 1) AS INTEGER
DIM SHARED graph(17900 * 1.5) AS INTEGER, graphindex
DIM SHARED img(90, 1) AS INTEGER, imgc
DIM SHARED anim(70, 1) AS INTEGER
DIM SHARED digger AS DIGGERTYPE
DIM SHARED enemy(1 TO 5) AS ENEMYTYPE, enemyc
DIM SHARED bag(1 TO 20) AS PICKUPTYPE, bagc
DIM SHARED gold(1 TO 20) AS PICKUPTYPE, goldc
DIM SHARED emerald(1 TO 100) AS PICKUPTYPE, emeraldc
DIM SHARED hiscore(hiscorec - 1) AS SCORETYPE
DIM SHARED nest AS NESTTYPE
DIM SHARED levidx(1 TO 256) AS STRING * 1
DIM SHARED bgrc, curbgr, consemer
DIM SHARED curlevel, bonusmode, bonusscore
DIM SHARED levelpack$
DIM SHARED tcons AS TIMEINT
DIM SHARED noretrace, gamestate
DIM SHARED speed AS SINGLE
DIM SHARED shotc AS INTEGER
DIM SHARED gameresult

speed = 1
noretrace = FALSE
levelpack$ = COMMAND$

INIT
DO
	curlevel = 0
	SETPAL pal.normal
	RESTOREFIELD
	NEWGAME
	ADDSCORE -1
	CHECKNEWHISCORE digger.score, gameresult
LOOP UNTIL gamestate = gs.quit
QUIT


data.levidx:
DATA 43
DATA "1","2","3","4","5","6","7","8","6","7","8"
DATA "5","6","7","8"
DATA "5","6","7","8"
DATA "5","6","7","8"
DATA "5","6","7","8"
DATA "5","6","7","8"
DATA "5","6","7","8"
DATA "5","6","7","8"
DATA "5","6","7","8"

data.levels:

DATA "_mine #1"
DATA " :::$:::::    e"
DATA " ::77::7:: :$::"
DATA " $:77::7:: ::::"
DATA " ::77$:7$: :777"
DATA " ::77::7:: :777"
DATA "  :77::7:: :777"
DATA ": ::::$:$: ::::"
DATA ":    ::::: ::::"
DATA "7::: ::::: :::7"
DATA "77::   d   ::77"

DATA "_mine #2"
DATA "      ::$:$:: e"
DATA ":77:: ::::::: :"
DATA ":77:: :77777: :"
DATA "$77$: :77777: :"
DATA "7777: ::::::: :"
DATA "7777: :$::    :"
DATA ":77:: :77: ::::"
DATA ":$$:: 7777 :77:"
DATA "7:::: :77: :77:"
DATA "77:::  d   ::::"

DATA "_mine #3"
DATA "     $:$:$    e"
DATA "77:: :7:7: :$$:"
DATA "7::: :7:7: :77:"
DATA ":$$: :7:7: 7777"
DATA "7777 :7:7: 7777"
DATA "7777       :77:"
DATA ":77::7: :7::77:"
DATA ":77::7: :7:::::"
DATA "7::::7: :7::::7"
DATA "77:::7:d:7:::77"

DATA "_mine #4"
DATA "  $7777$7777$  "
DATA "7 ::7777777:: 7"
DATA "7   :77777:   7"
DATA "7:: ::777:: ::7"
DATA ":::   :7:   :::"
DATA "::$:: :$: ::$::"
DATA "::7:: 777 ::7::"
DATA ":777:     :777:"
DATA "77777:7 7:77777"
DATA "77777:7d7:77777"

DATA "_mine #5"
DATA "              e"
DATA " $7777$ 777777 "
DATA " 777777 :77$7: "
DATA " :7777: 77$777 "
DATA " 777777 :7777: "
DATA " :7777: $77777 "
DATA " 77$777 :7777: "
DATA " :77$7: 777777 "
DATA " 777777 777777 "
DATA "       d       "

DATA "_mine #6"
DATA "              e"
DATA " 7$77 : : 77$7 "
DATA " 777: $ $ :777 "
DATA " 777  : :  777 "
DATA " 77: :7 7: :77 "
DATA " 77  :7 7:  77 "
DATA " 7: :77 77: :7 "
DATA " 7  $77 77$  7 "
DATA " 7 7777 7777 7 "
DATA "       d       "

DATA "_mine #7"
DATA "  77777 77777 e"
DATA ": 7$7$7 7$7$7 :"
DATA "$ 77777 77777 $"
DATA "7  7777 7777  7"
DATA "77 :777 777: 77"
DATA "77   77 77   77"
DATA "7777 :7 7: 7777"
DATA "7777  : :  7777"
DATA "77777 : : 77777"
DATA "77777  d  77777"

DATA "_mine #8"
DATA "              e"
DATA " :77$77777$77: "
DATA "   7777$7777   "
DATA " $ :7777777: $ "
DATA " 7   77777   7 "
DATA " 77$ :777: $77 "
DATA " 777   7   777 "
DATA " 7777: : :7777 "
DATA " 77777 : 77777 "
DATA "       d       "

DATA "_end"

data.gfx:
'stats = 0
DATA 11
DATA 12,12
DATA "011111111000"
DATA "111111111100"
DATA "110000001100"
DATA "110000001100"
DATA "110000001100"
DATA "110000111100"
DATA "110000111100"
DATA "110000111100"
DATA "110000111100"
DATA "110000111100"
DATA "111111111100"
DATA "011111111000"
DATA 12,12
DATA "000001100000"
DATA "000001100000"
DATA "000001100000"
DATA "000001100000"
DATA "000001100000"
DATA "000011100000"
DATA "000011100000"
DATA "000011100000"
DATA "000011100000"
DATA "000011100000"
DATA "000011100000"
DATA "000011100000"
DATA 12,12
DATA "011111111000"
DATA "111111111100"
DATA "110000001100"
DATA "000000001100"
DATA "000000001100"
DATA "000000001100"
DATA "011111111100"
DATA "111111111000"
DATA "111100000000"
DATA "111100000000"
DATA "111111111100"
DATA "011111111100"
DATA 12,12
DATA "011111100000"
DATA "111111110000"
DATA "110000110000"
DATA "110000110000"
DATA "000000110000"
DATA "001111111000"
DATA "001111111100"
DATA "000000011100"
DATA "110000011100"
DATA "110000011100"
DATA "111111111100"
DATA "011111111000"
DATA 12,12
DATA "110000000000"
DATA "110000000000"
DATA "110000110000"
DATA "110000110000"
DATA "110000110000"
DATA "110000110000"
DATA "110000110000"
DATA "111111111100"
DATA "011111111100"
DATA "000001110000"
DATA "000001110000"
DATA "000001110000"
DATA 12,12
DATA "011111110000"
DATA "111111110000"
DATA "110000000000"
DATA "110000000000"
DATA "110000000000"
DATA "111111111000"
DATA "011111111100"
DATA "000000111100"
DATA "110000111100"
DATA "110000111100"
DATA "111111111100"
DATA "011111111000"
DATA 12,12
DATA "011111111000"
DATA "111111111100"
DATA "110000001100"
DATA "110000001100"
DATA "110000000000"
DATA "111111111000"
DATA "111111111100"
DATA "110000111100"
DATA "110000111100"
DATA "110000111100"
DATA "111111111100"
DATA "011111111000"
DATA 12,12
DATA "011111111000"
DATA "011111111100"
DATA "000000001100"
DATA "000000001100"
DATA "000000001100"
DATA "000000001100"
DATA "000000011100"
DATA "000000011100"
DATA "000000011100"
DATA "000000011100"
DATA "000000011100"
DATA "000000011100"
DATA 12,12
DATA "000111110000"
DATA "001111111000"
DATA "001100011000"
DATA "001100011000"
DATA "001100011000"
DATA "001111111000"
DATA "011111111100"
DATA "110000011100"
DATA "110000011100"
DATA "110000011100"
DATA "111111111100"
DATA "011111111000"
DATA 12,12
DATA "011111111000"
DATA "111111111100"
DATA "110000001100"
DATA "110000001100"
DATA "110000001100"
DATA "111111111100"
DATA "011111111100"
DATA "000000111100"
DATA "000000111100"
DATA "000000111100"
DATA "000000111100"
DATA "000000111100"
DATA 16,12
DATA "4444444033044444"
DATA "4444440333304444"
DATA "0000040300300444"
DATA "1111102222222044"
DATA "1111112222222204"
DATA "0000112222222220"
DATA "1111112222222222"
DATA "1111102002222002"
DATA "0000040330220330"
DATA "4444403003003003"
DATA "4444403003003003"
DATA "4444440330440330"

'backgrounds = 1
DATA 8
DATA 20,4
DATA "22333333222233333322"
DATA "32233332233223333223"
DATA "33223322333322332233"
DATA "33322223333332222333"
DATA 20,4
DATA "11221122112211221122"
DATA "21122112211221122112"
DATA "22112211221122112211"
DATA "21122112211221122112"
DATA 20,4
DATA "22332233223322332233"
DATA "32233223322332233223"
DATA "33223322332233223322"
DATA "23322332233223322332"
DATA 20,4
DATA "11333333111133333311"
DATA "31133331133113333113"
DATA "33113311333311331133"
DATA "33311113333331111333"
DATA 20,4
DATA "22333333222233333322"
DATA "31133331133113333113"
DATA "33223322333322332233"
DATA "33311113333331111333"
DATA 20,4
DATA "11221122112211221122"
DATA "21122112211221122112"
DATA "11221122112211221122"
DATA "21122112211221122112"
DATA 20,4
DATA "22332233223322332233"
DATA "31133113311331133113"
DATA "33113311331133113311"
DATA "23322332233223322332"
DATA 20,4
DATA "33223322332233223322"
DATA "23322332233223322332"
DATA "22332233223322332233"
DATA "23322332233223322332"

'digger: left = 2
DATA 3
DATA 16,15
DATA "4444444444444444"
DATA "4444444033044444"
DATA "4444440333304444"
DATA "4444440300304444"
DATA "4444440300304444"
DATA "0000040300300444"
DATA "1111102222222044"
DATA "1111112222222204"
DATA "0000112222222220"
DATA "1111112222222002"
DATA "1111102002220330"
DATA "0000040330203003"
DATA "4444403003003003"
DATA "4444403003040330"
DATA "4444440330444004"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444033044444"
DATA "4444440333304444"
DATA "4000040300304444"
DATA "0111100300300444"
DATA "0111112222222044"
DATA "4001112222222204"
DATA "4440112222222220"
DATA "4001112002222222"
DATA "0111110330022002"
DATA "0111103003000330"
DATA "4000003003003003"
DATA "4444440330403003"
DATA "4444444004440330"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444400444444"
DATA "4400444033044444"
DATA "4011040333304444"
DATA "4011100300300444"
DATA "4401112222222044"
DATA "4440112222222204"
DATA "4440112222222220"
DATA "4440112222222002"
DATA "4401112002220330"
DATA "4011100330203003"
DATA "4011003003003003"
DATA "4400403003040330"
DATA "4444440330444004"

'digger: right = 3
DATA 3
DATA 16,15
DATA "4444444444444444"
DATA "4444403304444444"
DATA "4444033330444444"
DATA "4444030030444444"
DATA "4444030030444444"
DATA "4440030030400000"
DATA "4402222222011111"
DATA "4022222222111111"
DATA "0222222222110000"
DATA "2002222222111111"
DATA "0330222002011111"
DATA "3003020330400000"
DATA "3003003003044444"
DATA "0330403003044444"
DATA "4004440330444444"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444403304444444"
DATA "4444033330444444"
DATA "4444030030440004"
DATA "4440030030001110"
DATA "4402222222111110"
DATA "4022222222111004"
DATA "0222222222110444"
DATA "2222222002111004"
DATA "2002220330111110"
DATA "0330203003001110"
DATA "3003003003040004"
DATA "3003040330444444"
DATA "0330444004444444"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444403304440044"
DATA "4444033330401104"
DATA "4440030030011104"
DATA "4402222222111044"
DATA "4022222222110444"
DATA "0222222222110444"
DATA "2002222222110444"
DATA "0330222002111044"
DATA "3003020330011104"
DATA "3003003003001104"
DATA "0330403003040044"
DATA "4004440330444444"

'digger: up = 4
DATA 3
DATA 16,15
DATA "4440110110444444"
DATA "4440110110444444"
DATA "4440110110444444"
DATA "4440110110444444"
DATA "4004011104444444"
DATA "0330222220000444"
DATA "3003022223333044"
DATA "3003022220003304"
DATA "0330222220003304"
DATA "4000222223333044"
DATA "4400222220000444"
DATA "4033022220444444"
DATA "0300302204444444"
DATA "0300302044444444"
DATA "4033020444444444"
DATA 16,15
DATA "4401104011044444"
DATA "4401104011044444"
DATA "4401110111044444"
DATA "4401111111044444"
DATA "4400111110444444"
DATA "4033022220004444"
DATA "0300302223330444"
DATA "0300302220033044"
DATA "4033022220033044"
DATA "4400022223330444"
DATA "4000222220004444"
DATA "0330222220444444"
DATA "3003022204444444"
DATA "3003022444444444"
DATA "0330224444444444"
DATA 16,15
DATA "4400444440044444"
DATA "4011044401104444"
DATA "4011100011104444"
DATA "4401111111044444"
DATA "4000111110444444"
DATA "0330222220044444"
DATA "3003022223304444"
DATA "3003022220330444"
DATA "0330222220330444"
DATA "4000222223304444"
DATA "4400222220044444"
DATA "4033022220444444"
DATA "0300302204444444"
DATA "0300302044444444"
DATA "4033020444444444"

'digger: down = 5
DATA 3
DATA 16,15
DATA "4444444402033044"
DATA "4444444020300304"
DATA "4444440220300304"
DATA "4444402222033044"
DATA "4400002222200444"
DATA "4033332222200044"
DATA "0330002222203304"
DATA "0330002222030034"
DATA "4033332222030034"
DATA "4400002222203304"
DATA "4444440111040044"
DATA "4444401111104444"
DATA "4444401101104444"
DATA "4444401101104444"
DATA "4444401101104444"
DATA 16,15
DATA "4444444402203304"
DATA "4444444022030034"
DATA "4444440222030034"
DATA "4444402222203304"
DATA "4440002222200044"
DATA "4403332222000444"
DATA "4033002222033044"
DATA "4033002220300304"
DATA "4403332220300304"
DATA "4440002222033044"
DATA "4444401111000444"
DATA "4444011101110444"
DATA "4444011040110444"
DATA "4444011040110444"
DATA "4444011040110444"
DATA 16,15
DATA "4444444402033044"
DATA "4444444020300304"
DATA "4444440220300304"
DATA "4444402222033044"
DATA "4444002222200444"
DATA "4440332222200044"
DATA "4403302222203304"
DATA "4403302222030034"
DATA "4440332222030034"
DATA "4444002222203304"
DATA "4444401111100044"
DATA "4444011111110444"
DATA "4440111000111044"
DATA "4440110444011044"
DATA "4444004444400444"

'digger: leftx = 6
DATA 3
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444400444444"
DATA "4444444033044444"
DATA "0000040333300444"
DATA "1111102222222044"
DATA "1111112222222204"
DATA "0000112222222220"
DATA "1111112222222002"
DATA "1111102002220330"
DATA "0000040330203003"
DATA "4444403003003003"
DATA "4444403003040330"
DATA "4444440330444004"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444400444444"
DATA "4000044033044444"
DATA "0111100333300444"
DATA "0111112222222044"
DATA "4001112222222204"
DATA "4440112222222220"
DATA "4001112002222222"
DATA "0111110330022002"
DATA "0111103003000330"
DATA "4000003003003003"
DATA "4444440330403003"
DATA "4444444004440330"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4400444400444444"
DATA "4011044033044444"
DATA "4011100333300444"
DATA "4401112222222044"
DATA "4440112222222204"
DATA "4440112222222220"
DATA "4440112222222002"
DATA "4401112002220330"
DATA "4011100330203003"
DATA "4011003003003003"
DATA "4400403003040330"
DATA "4444440330444004"

'digger: rightx = 7
DATA 3
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444440044444444"
DATA "4444403304444444"
DATA "4440033330400000"
DATA "4402222222011111"
DATA "4022222222111111"
DATA "0222222222110000"
DATA "2002222222111111"
DATA "0330222002011111"
DATA "3003020330400000"
DATA "3003003003044444"
DATA "0330403003044444"
DATA "4004440330444444"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444440044444444"
DATA "4444403304440004"
DATA "4440033330001110"
DATA "4402222222111110"
DATA "4022222222111004"
DATA "0222222222110444"
DATA "2222222002111004"
DATA "2002220330111110"
DATA "0330203003001110"
DATA "3003003003040004"
DATA "3003040330444444"
DATA "0330444004444444"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444440044440044"
DATA "4444403304401104"
DATA "4440033330011104"
DATA "4402222222111044"
DATA "4022222222110444"
DATA "0222222222110444"
DATA "2002222222110444"
DATA "0330222002111044"
DATA "3003020330011104"
DATA "3003003003001104"
DATA "0330403003040044"
DATA "4004440330444444"

'digger: upx = 8
DATA 3
DATA 16,15
DATA "4440110110444444"
DATA "4440110110444444"
DATA "4440110110444444"
DATA "4440110110444444"
DATA "4004011104444444"
DATA "0330222220444444"
DATA "3003022223044444"
DATA "3003022223304444"
DATA "0330222223304444"
DATA "4000222223044444"
DATA "4400222220444444"
DATA "4033022220444444"
DATA "0300302204444444"
DATA "0300302044444444"
DATA "4033020444444444"
DATA 16,15
DATA "4401104011044444"
DATA "4401104011044444"
DATA "4401110111044444"
DATA "4401111111044444"
DATA "4400111110444444"
DATA "4033022220444444"
DATA "0300302223044444"
DATA "0300302223304444"
DATA "4033022223304444"
DATA "4400022223044444"
DATA "4000222220444444"
DATA "0330222220444444"
DATA "3003022204444444"
DATA "3003022044444444"
DATA "0330220444444444"
DATA 16,15
DATA "4400444440044444"
DATA "4011044401104444"
DATA "4011100011104444"
DATA "4401111111044444"
DATA "4000111110444444"
DATA "0330222220444444"
DATA "3003022223044444"
DATA "3003022223304444"
DATA "0330222223304444"
DATA "4000222223044444"
DATA "4400222220444444"
DATA "4033022220444444"
DATA "0300302204444444"
DATA "0300302044444444"
DATA "4033020444444444"

'digger: downx = 9
DATA 3
DATA 16,15
DATA "4444444402033044"
DATA "4444444020300304"
DATA "4444440220300304"
DATA "4444402222033044"
DATA "4444402222200444"
DATA "4444032222200044"
DATA "4440332222203304"
DATA "4440332222030034"
DATA "4444032222030034"
DATA "4444402222203304"
DATA "4444440111040044"
DATA "4444401111104444"
DATA "4444401101104444"
DATA "4444401101104444"
DATA "4444401101104444"
DATA 16,15
DATA "4444444402203304"
DATA "4444444022030034"
DATA "4444440222030034"
DATA "4444402222203304"
DATA "4444402222200044"
DATA "4444032222000444"
DATA "4440332222033044"
DATA "4440332220300304"
DATA "4444032220300304"
DATA "4444402222033044"
DATA "4444401111000444"
DATA "4444011101110444"
DATA "4444011040110444"
DATA "4444011040110444"
DATA "4444011040110444"
DATA 16,15
DATA "4444444402033044"
DATA "4444444020300304"
DATA "4444440220300304"
DATA "4444402222033044"
DATA "4444402222200444"
DATA "4444032222200044"
DATA "4440332222203304"
DATA "4440332222030034"
DATA "4444032222030034"
DATA "4444402222203304"
DATA "4444401111100044"
DATA "4444011111110444"
DATA "4440111000111044"
DATA "4440110444011044"
DATA "4444004444400444"

'digger: die = 10
DATA 6
DATA 16,15
DATA "4444444004444004"
DATA "4444440330440330"
DATA "4444403303003333"
DATA "4400003333003303"
DATA "0011100330220330"
DATA "1111112002222002"
DATA "1100112222222220"
DATA "0011112222222204"
DATA "1111102222222044"
DATA "1100040300330444"
DATA "0044440030300444"
DATA "4444440300330444"
DATA "4444444033330444"
DATA "4444444403304444"
DATA "4444444440044444"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444440004444444"
DATA "4444001110044444"
DATA "4400113331100444"
DATA "4011333333311044"
DATA "4013333333331044"
DATA "0000000000000004"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444440004444444"
DATA "4444001110044444"
DATA "4400113331100444"
DATA "4011333333311044"
DATA "4013333333331044"
DATA "0100003333333104"
DATA "0103303033333104"
DATA "0000000000000004"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444440004444444"
DATA "4444001110044444"
DATA "4400113331100444"
DATA "4011333333311044"
DATA "4013333333331044"
DATA "0100003333333104"
DATA "0103303033333104"
DATA "0100003030000104"
DATA "0100333030330104"
DATA "0000000000000004"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444440004444444"
DATA "4444001110044444"
DATA "4400113331100444"
DATA "4011333333311044"
DATA "4013333333331044"
DATA "0100003333333104"
DATA "0103303033333104"
DATA "0100003030000104"
DATA "0100333030330104"
DATA "0103033030000104"
DATA "0103303030333104"
DATA "0133333030333104"
DATA "0000000000000004"
DATA 16,15
DATA "4444440004444444"
DATA "4444001110044444"
DATA "4400113331100444"
DATA "4011333333311044"
DATA "4013333333331044"
DATA "0100003333333104"
DATA "0103303033333104"
DATA "0100003030000104"
DATA "0100333030330104"
DATA "0103033030000104"
DATA "0103303030333104"
DATA "0133333030333104"
DATA "0133333330333104"
DATA "0133333333333104"
DATA "0133333333333104"

'nobbin: walk = 11
DATA 3
DATA 16,15
DATA "4440004444000444"
DATA "4403330000333044"
DATA "4033333113333304"
DATA "4030033113003304"
DATA "4030033113003304"
DATA "4403331111333044"
DATA "4440111111110444"
DATA "4440011111100444"
DATA "4402201001022044"
DATA "4022001111002204"
DATA "4022040110402204"
DATA "4022044004022220"
DATA "4022044440222222"
DATA "0222204444000000"
DATA "2222220444444444"
DATA 16,15
DATA "4440004444000444"
DATA "4403330000333044"
DATA "4033333113333304"
DATA "4033003113300304"
DATA "4033003113300304"
DATA "4403331111333044"
DATA "4440111111110444"
DATA "4440011001100444"
DATA "4402201001022044"
DATA "4022001111002204"
DATA "4022040110402204"
DATA "4022044004402204"
DATA "0222244444022220"
DATA "2222224440222222"
DATA "0000004444000000"
DATA 16,15
DATA "4440004444000444"
DATA "4403330000333044"
DATA "4033003113300304"
DATA "4033003113300304"
DATA "4033333113333304"
DATA "4403331111333044"
DATA "4440111001110444"
DATA "4440011001100444"
DATA "4402201001022044"
DATA "4022001001002204"
DATA "4022040110402204"
DATA "0222204004402204"
DATA "2222220444402204"
DATA "0000004444022220"
DATA "4444444440222222"

'nobbin: die = 12
DATA 1
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4440004444000444"
DATA "4403330000333044"
DATA "4030033113300304"
DATA "4030033113300304"
DATA "4033333113333304"
DATA "4403331111333044"
DATA "4440111001110444"
DATA "4440011001100444"
DATA "4402201001022044"
DATA "4022001001002204"
DATA "0222200110022220"
DATA "2222220000222222"
DATA "0000004444000000"

'hobbin: left = 13
DATA 3
DATA 16,15
DATA "4444010333010444"
DATA "4440103333301044"
DATA "4440103300301104"
DATA "4401103300301110"
DATA "4011110333011110"
DATA "0111111000111110"
DATA "4022222111111104"
DATA "4400000211111044"
DATA "4022222111110444"
DATA "4401111111104444"
DATA "4440000220044444"
DATA "4444440220444444"
DATA "4444440220444444"
DATA "4444402222044444"
DATA "4444022222204444"
DATA 16,15
DATA "4444010333010444"
DATA "4440103333301044"
DATA "4401103003301104"
DATA "4011103003301110"
DATA "0111110333011110"
DATA "0222111000111110"
DATA "4000222111111104"
DATA "4444000211111044"
DATA "4400022111110444"
DATA "4022211111104444"
DATA "4411100220044444"
DATA "4440040220444444"
DATA "4444402222044444"
DATA "4444022222204444"
DATA "4444400000044444"
DATA 16,15
DATA "4444010333010444"
DATA "4440103003301044"
DATA "4401103003301104"
DATA "4011103333301110"
DATA "0221110333011110"
DATA "4002211000111110"
DATA "4440022111111104"
DATA "4444000211111044"
DATA "4400022111110444"
DATA "4402211111104444"
DATA "4421100220044444"
DATA "4440002222044444"
DATA "4444022222204444"
DATA "4444400000044444"
DATA "4444444444444444"

'hobbin: right = 14
DATA 3
DATA 16,15
DATA "4440103330104444"
DATA "4401033333010444"
DATA "4011030033010444"
DATA "0111030033011044"
DATA "0111103330111104"
DATA "0111110001111110"
DATA "4011111112222204"
DATA "4401111120000044"
DATA "4440111112222204"
DATA "4444011111111044"
DATA "4444400220000444"
DATA "4444440220444444"
DATA "4444440220444444"
DATA "4444402222044444"
DATA "4444022222204444"
DATA 16,15
DATA "4440103330104444"
DATA "4401033333010444"
DATA "4011033003011444"
DATA "0111033003011144"
DATA "0111103330111114"
DATA "0111110001112224"
DATA "4011111112220044"
DATA "4401111120004444"
DATA "4440111112200044"
DATA "4444011111122204"
DATA "4444400220011144"
DATA "4444440220400444"
DATA "4444402222044444"
DATA "4444022222204444"
DATA "4444400000044444"
DATA 16,15
DATA "4440103330104444"
DATA "4401033003010444"
DATA "4011033003011044"
DATA "0111033333011104"
DATA "0111103330111220"
DATA "0111110001122004"
DATA "4011111112200444"
DATA "4401111120044444"
DATA "4440111112200444"
DATA "4444011111122004"
DATA "4444400220011204"
DATA "4444402222000044"
DATA "4444022222204444"
DATA "4444400000044444"
DATA "4444444444444444"

'hobbin: dieleft = 15
DATA 1
DATA 16,14
DATA "4444400000004444"
DATA "4444010333010444"
DATA "4440103003301044"
DATA "4401103003301104"
DATA "4011103333301110"
DATA "0221110333011110"
DATA "4002211000111110"
DATA "4440022111111104"
DATA "4440022211111044"
DATA "4402221111110444"
DATA "4222111111104444"
DATA "4400002222044444"
DATA "4444022222204444"
DATA "4444400000044444"

'hobbin: dieright = 16
DATA 1
DATA 16,15
DATA "4444444444444444"
DATA "4444000000044444"
DATA "4440103330104444"
DATA "4401033003010444"
DATA "4011033003011044"
DATA "0111033333011104"
DATA "0111103330111220"
DATA "0111110001122004"
DATA "4011111112200444"
DATA "4401111122244444"
DATA "4440111111222444"
DATA "4444011111112224"
DATA "4444402222000004"
DATA "4444022222204444"
DATA "4444400000044444"

'emerald = 17
DATA 1
DATA 14,10
DATA "44400000000044"
DATA "44001111111004"
DATA "40011311111100"
DATA "00113111111110"
DATA "40011311110100"
DATA "44001111101004"
DATA "44400111010044"
DATA "44440011100444"
DATA "44444001004444"
DATA "44444400044444"

'goldbag: moveleft = 18
DATA 1
DATA 16,15
DATA "4444400004444444"
DATA "4444033330444444"
DATA "4444403304444444"
DATA "4444033330044444"
DATA "4440333333304444"
DATA "4403330033330444"
DATA "4030000000033044"
DATA "0300330033333304"
DATA "0300000000003304"
DATA "0333330033003304"
DATA "0300330033003304"
DATA "0330000000033044"
DATA "4033330033330444"
DATA "4400333333004444"
DATA "4444000000444444"

'goldbag: normal = 19
DATA 1
DATA 16,15
DATA "4444400000044444"
DATA "4444403333044444"
DATA "4444440330444444"
DATA "4444003333004444"
DATA "4440333333330444"
DATA "4403333003333044"
DATA "4033000000003304"
DATA "0330033003333330"
DATA "0330000000000330"
DATA "0333333003300330"
DATA "0330033003300330"
DATA "0333000000003330"
DATA "4033333003333304"
DATA "4400333333330044"
DATA "4444000000004444"

'goldbag: moveright = 20
DATA 1
DATA 16,15
DATA "4444444000044444"
DATA "4444440333304444"
DATA "4444440033044444"
DATA "4444403333304444"
DATA "4444033333330444"
DATA "4440333300333044"
DATA "4403300000000304"
DATA "4033003300333330"
DATA "4033000000000030"
DATA "4033333300330030"
DATA "4033003300330030"
DATA "4403300000000304"
DATA "4440333300333044"
DATA "4444003333300444"
DATA "4444440000044444"

'goldbag: fall = 21
DATA 1
DATA 16,15
DATA "4444403003044444"
DATA "4444440330444444"
DATA "4444440330444444"
DATA "4444403333044444"
DATA "4444033333304444"
DATA "4440333003330444"
DATA "4403000000003044"
DATA "4030033003333304"
DATA "4030000000000304"
DATA "4033333003300304"
DATA "4030033003300304"
DATA "4403000000003044"
DATA "4440333003330444"
DATA "4444033333304444"
DATA "4444400330044444"

'bonus = 22
DATA 1
DATA 16,15
DATA "4000000011100004"
DATA "0000000111110000"
DATA "0000000110110000"
DATA "0000001100011000"
DATA "0000001100001100"
DATA "0000011000101101"
DATA "0000011000011110"
DATA "0010110100001100"
DATA "0001111000022200"
DATA "0002220000233220"
DATA "0023322002332222"
DATA "0223222202222222"
DATA "0222222200222220"
DATA "0022222000022200"
DATA "4002220000000004"

'falling coins = 23
DATA 3
DATA 16,15
DATA "4444444004444444"
DATA "4444440330444444"
DATA "4444003333044444"
DATA "4440330333044444"
DATA "4403333030304444"
DATA "4033333303330444"
DATA "4033333303333044"
DATA "4403333033333044"
DATA "4440330033330444"
DATA "4403003300004444"
DATA "4033330303304444"
DATA "4333333033330444"
DATA "0333333033333044"
DATA "4033330333333044"
DATA "4403303033330444"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444004444"
DATA "4444004440330444"
DATA "4440330403333044"
DATA "4403333033333304"
DATA "4033333303333304"
DATA "4033333300333044"
DATA "4403333033030444"
DATA "4400330333304444"
DATA "4033003333030444"
DATA "4333300330333044"
DATA "0333330003333304"
DATA "4033330303333304"
DATA "4403303330333044"
DATA 16,15
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4444444444444444"
DATA "4440044444400444"
DATA "4403304000033044"
DATA "4033330330333304"
DATA "0333333033033330"
DATA "0333333033303330"
DATA "4033330033300004"
DATA "4003300333033304"
DATA "0330030000333330"
DATA "0333330330333330"
DATA "4033303333033304"

'explosion = 24
DATA 3
DATA 8,8
DATA "00444400"
DATA "03000030"
DATA "40322304"
DATA "44022044"
DATA "40322304"
DATA "03000030"
DATA "00444400"
DATA "44444444"
DATA 8,8
DATA "30444403"
DATA "03044030"
DATA "40244204"
DATA "44044044"
DATA "40244204"
DATA "03044030"
DATA "30444403"
DATA "44444444"
DATA 8,8
DATA "20444402"
DATA "03044030"
DATA "40444404"
DATA "44444444"
DATA "40444404"
DATA "03044030"
DATA "20444402"
DATA "44444444"

' fire = 25
DATA 3
DATA 8,8
DATA "40033004"
DATA "02302332"
DATA "03233030"
DATA "33033323"
DATA "03303330"
DATA "03033030"
DATA "43032304"
DATA "44444444"
DATA 8,8
DATA "40232424"
DATA "03302232"
DATA "00223024"
DATA "33032322"
DATA "22302032"
DATA "22032202"
DATA "42432024"
DATA "44444444"
DATA 8,8
DATA "40220224"
DATA "02032202"
DATA "20222022"
DATA "23032220"
DATA "02222322"
DATA "22032203"
DATA "40222024"
DATA "44444444"

' digleft = 26
DATA 1
DATA 8,18
DATA "44444400"
DATA "44440000"
DATA "44400000"
DATA "44000000"
DATA "44000000"
DATA "40000000"
DATA "00000000"
DATA "00000000"
DATA "00000000"
DATA "00000000"
DATA "00000000"
DATA "00000000"
DATA "40000000"
DATA "44000000"
DATA "44000000"
DATA "44400000"
DATA "44444004"
DATA "44440044"

' digright = 27
DATA 1
DATA 8,18
DATA "44004444"
DATA "00004444"
DATA "00000444"
DATA "00000044"
DATA "00000044"
DATA "00000004"
DATA "00000000"
DATA "00000000"
DATA "00000000"
DATA "00000000"
DATA "00000000"
DATA "00000000"
DATA "00000004"
DATA "00000044"
DATA "00000444"
DATA "00000444"
DATA "40044444"
DATA "00444444"

'digup = 28
DATA 1
DATA 24,6
DATA "444444444000000444444444"
DATA "444444400000000004444444"
DATA "444444000000000000044444"
DATA "444000000000000000000444"
DATA "440000000000000000004444"
DATA "444400000000000000000044"

'digdown = 29
DATA 1
DATA 24,6
DATA "444000000000000000000444"
DATA "440000000000000000004444"
DATA "444400000000000000000044"
DATA "444440000000000000044444"
DATA "444444400000000004444444"
DATA "444444444000000444444444"

REM $STATIC
SUB ADD (obj, cx, cy)
	GETCELLCOORDS cx, cy, x, y
	SELECT CASE obj
		CASE newnobbin
			enemyc = enemyc + 1
			enemy(enemyc).x = x
			enemy(enemyc).y = y
			enemy(enemyc).stpx = x
			enemy(enemyc).stpy = y
			enemy(enemyc).trgx = cx
			enemy(enemyc).trgy = cy
			enemy(enemyc).mode = enm.nobbin
			enemy(enemyc).thob.starttime = TIMER
			enemy(enemyc).thob.interval = tim.nobbin
			enemy(enemyc).pic.mode = ani.nobbin
			enemy(enemyc).pic.frame = 0
		CASE newemerald
			emeraldc = emeraldc + 1
			emerald(emeraldc).x = x
			emerald(emeraldc).y = y + 3
			emerald(emeraldc).use = TRUE
			emerald(emeraldc).mode = 0
			emerald(emeraldc).pic.mode = ani.emerald
			emerald(emeraldc).pic.frame = 0
			DRAWPIC emerald(emeraldc).x, emerald(emeraldc).y, emerald(emeraldc).pic, FALSE
		CASE newbag
			bagc = bagc + 1
			bag(bagc).x = x
			bag(bagc).y = y
			bag(bagc).mode = gld.normal
			bag(bagc).use = TRUE
			bag(bagc).misc = 0
			bag(bagc).fally = 0
			bag(bagc).pic.mode = ani.bag
			DRAWPIC x, y, bag(bagc).pic, FALSE
		CASE newgold
			goldc = goldc + 1
			gold(goldc).x = x
			gold(goldc).y = y
			gold(goldc).pic.mode = ani.coins
			gold(goldc).pic.frame = -1
			gold(goldc).t.interval = 10
			gold(goldc).t.starttime = TIMER
	END SELECT
END SUB

SUB ADDSCORE (amount)
STATIC addition AS LONG
STATIC t AS TIMEINT
STATIC newlife AS LONG
STATIC palflag
	t.interval = .01
	IF amount < 0 THEN
		digger.score = digger.score + addition
		SHOWSCORE digger.score, digger.lives
		addition = 0
		EXIT SUB
	END IF
	addition = addition + amount
	IF TEVENT(t) THEN
		IF digger.score = 0 THEN newlife = lifecost
		IF palflag >= 1 THEN
			palflag = palflag - 1
			IF palflag = 0 THEN PALETTE 0, 0
		END IF
		IF digger.score + addition >= newlife THEN
			PALETTE 0, 6'2 + 16 + 16 + 16
			palflag = 3
			newlife = newlife + lifecost
			IF digger.lives < 9 THEN digger.lives = digger.lives + 1
		END IF
		FOR i = 1 TO addition \ 5 + 1
			IF addition <= 0 THEN EXIT FOR
			addition = addition - 1
			digger.score = digger.score + 1
		NEXT
	END IF
END SUB

SUB ANIMATE (x, y, p AS PICPAR, redr)
	IF redr THEN
		IF p.frame >= 0 THEN ERASEPIC x, y, p
		p.frame = (p.frame + 1) MOD anim(p.mode, framec)
		DRAWPIC x, y, p, FALSE
	ELSE
		p.frame = (p.frame + 1) MOD anim(p.mode, framec)
	END IF
END SUB

FUNCTION BOXCOLL (x, y, w, h, ax, ay, aw, ah)
	x2 = x + w - 1
	y2 = y + h - 1
	ax2 = ax + aw - 1
	ay2 = ay + ah - 1
	IF x > ax THEN xr1 = x ELSE xr1 = ax
	IF y > ay THEN yr1 = y ELSE yr1 = ay
	IF x2 < ax2 THEN xr2 = x2 ELSE xr2 = ax2
	IF y2 < ay2 THEN yr2 = y2 ELSE yr2 = ay2
	wr = xr2 - xr1
	hr = yr2 - yr1
	IF wr < 0 OR hr < 0 THEN BOXCOLL = FALSE ELSE BOXCOLL = TRUE
END FUNCTION

FUNCTION CHECKBAGSHIFT (x, y, dir)
	FOR i = 1 TO bagc
		IF BOXCOLL(x + dir, y, imgw, imgh, bag(i).x, bag(i).y, cellw - 1, cellh) THEN
			IF bag(i).mode = bagm.normal AND dir <> 0 THEN r = SHIFTBAG(i, dir * diggerspeedx)
			CHECKBAGSHIFT = TRUE
			EXIT FUNCTION
		END IF
	NEXT
	CHECKBAGSHIFT = FALSE
END FUNCTION

SUB CHECKBONUS (x, y, scoreflag)
	IF bonus.use THEN
		'GETCELLCOORDS bonus.x, bonus.y, bx, by
		bx = bonus.x
		by = bonus.y
		IF BOXCOLL(x, y, imgw, imgh, bx, by, imgw, imgh) THEN
			ERASEIMG bx, by, anim(ani.bonus, img1)
			bonusmode = TRUE
			bonus.use = FALSE
			bonus.t.starttime = TIMER
			IF scoreflag THEN ADDSCORE 1000
			SETPAL pal.bonus
		ELSE
			DRAWIMG bx, by, anim(ani.bonus, img1), FALSE
		END IF
	END IF
END SUB

SUB CHECKEMERALDS (plx, ply, scoreflag)
	FOR i = emeraldc TO 1 STEP -1
		IF emerald(i).use AND BOXCOLL(plx, ply, imgw, imgh, emerald(i).x, emerald(i).y, emerw, emerh) THEN
			IF scoreflag THEN
				ADDSCORE 25
				consemer = consemer + 1
				tcons.starttime = TIMER
				IF consemer = 8 THEN ADDSCORE 250: consemer = 0
			END IF
			ERASEPIC emerald(i).x, emerald(i).y, emerald(i).pic
			SWAP emerald(emeraldc), emerald(i)
			emeraldc = emeraldc - 1
		END IF
	NEXT
END SUB

SUB CHECKGOLD (plx, ply, scoreflag)
	FOR i = goldc TO 1 STEP -1
		IF BOXCOLL(plx, ply, imgw + 2, imgh + 2, gold(i).x, gold(i).y + imgh * .4, imgw + 3, imgh * (1 - .4)) THEN
			IF scoreflag THEN ADDSCORE 500
			ERASEPIC gold(i).x, gold(i).y, gold(i).pic
			REDRAW gold(i).x, gold(i).y, emerald(), emeraldc
			SWAP gold(goldc), gold(i)
			goldc = goldc - 1
		END IF
	NEXT
END SUB

SUB CHECKKILL
CONST d = 4
	FOR i = enemyc TO 1 STEP -1
		IF (enemy(i).mode = enm.hobbin OR enemy(i).mode = enm.nobbin) AND BOXCOLL(enemy(i).x + d, enemy(i).y + d, imgw - d * 2, imgh - d * 2, digger.x, digger.y, imgw, imgh) THEN
			IF NOT bonusmode THEN
				gamestate = gs.killed
				ERASEPIC enemy(i).x, enemy(i).y, enemy(i).pic
				ERASEPIC digger.x, digger.y, digger.pic
				digger.pic.mode = ani.dgrdie
				digger.pic.frame = -1
				digger.mode = dgr.dead
				EXIT FOR
			ELSE
				ERASEPIC enemy(i).x, enemy(i).y, enemy(i).pic
				SWAP enemy(i), enemy(enemyc)
				enemyc = enemyc - 1
				bonusscore = bonusscore + 250
				ADDSCORE bonusscore
			END IF
		END IF
	NEXT
END SUB

SUB CHECKNEWHISCORE (score AS LONG, gameresult)
	IF score > hiscore(hiscorec - 1).score THEN
		FOR i = 0 TO hiscorec - 1
			IF hiscore(i).score < score THEN
				FOR j = hiscorec - 1 TO i + 1 STEP -1
					hiscore(j) = hiscore(j - 1)
				NEXT
				hiscore(i).score = score
				VIEW
				cw = 8: ch = 14
				LINE (cw * 10 + 2, ch * 4)-STEP(cw * 22 + 1, ch * 6 + 1), 0, BF
				IF gameresult = gr.gameover THEN
					COLOR redclr
					LOCATE 6, 14: PRINT "   GAME OVER!   "
				ELSEIF gameresult = gr.winner THEN
					COLOR goldclr
					LOCATE 6, 14: PRINT "CONGRATULATIONS!"
				ELSE
					COLOR greenclr
					LOCATE 6, 14: PRINT "  HIGH SCORE!!  "
				END IF
				COLOR greenclr
				LINE (cw * 10 + 2 + 2, ch * 4 + 2)-STEP(cw * 22 - 3, ch * 6 - 3), , B
				LOCATE 8, 14: PRINT "Enter your name:"
				LOCATE 9, 15: PRINT STRING$(namelen, ".")
				DO
					DO: k$ = INKEY$: LOOP WHILE LEN(k$) = 0
					SELECT CASE ASC(k$)
						CASE IS >= 32: IF LEN(name$) < namelen THEN name$ = name$ + k$
						CASE 8: IF LEN(name$) > 0 THEN name$ = LEFT$(name$, LEN(name$) - 1)
					END SELECT
					LOCATE 9, 15: PRINT name$ + STRING$(namelen - LEN(name$), ".")
				LOOP UNTIL k$ = CHR$(13)
				hiscore(i).uname = name$ + STRING$(namelen - LEN(name$), ".")
				UPDATESCORES
				EXIT FOR
			END IF
		NEXT
	END IF
END SUB

SUB CLOSELEVEL
	IF levelpack$ <> "" THEN CLOSE #1
END SUB

SUB DELAY (sec!)
	ct! = TIMER
	DO UNTIL ct! + sec! <= TIMER: a = LEN(INKEY$): LOOP
END SUB

SUB DRAWHOLE (x, y)
	SCANMAZECELL x, y, 0, l, r, u, d
	SCANMAZECELL x + 1, y, rc, 0, 0, 0, 0
	SCANMAZECELL x - 1, y, lc, 0, 0, 0, 0
	SCANMAZECELL x, y + 1, dc, 0, 0, 0, 0
	SCANMAZECELL x, y - 1, uc, 0, 0, 0, 0
	GETCELLCOORDS x, y, cx, cy
	IF l = FALSE OR (x = 0 AND (y = 0 OR y = mazey - 1 OR r = FALSE)) THEN
		FOR i = cx - 5 TO cx + 10 STEP diggerspeedx
			DRAWIMG i, cy - 1, iblob.left, FALSE
		NEXT
	END IF
	IF r = FALSE OR (x = mazex - 1 AND (y = 0 OR y = mazey - 1 OR l = FALSE)) THEN
		IF lc = mz.empty THEN delta = 1 ELSE delta = 0
		FOR i = cx + 10 + 1 - diggerspeedx * (3 + delta) TO cx + 10 + 1 STEP diggerspeedx
			DRAWIMG i, cy - 1, iblob.right, FALSE
		NEXT
	END IF
	IF u = FALSE OR (y = 0 AND (x = mazex - 1 OR x = 0)) THEN
		IF uc = FALSE THEN delta = 1 ELSE delta = 0
		FOR i = cy - 3 - diggerspeedy * delta TO cy - 3 + diggerspeedy * 4 STEP diggerspeedy
			DRAWIMG cx - 5, i, iblob.up, FALSE
		NEXT
	END IF
	IF d = FALSE OR (y = 0 AND (x = mazex - 1 OR x = 0)) THEN
		IF dc = mz.empty AND u = FALSE THEN delta = 1 ELSE delta = 0
		FOR i = cy + 12 - diggerspeedy * (4) TO cy + 12 + diggerspeedy * delta STEP diggerspeedy
			DRAWIMG cx - 5, i, iblob.down, FALSE
		NEXT
	END IF
END SUB

SUB DRAWIMG (x, y, imgn, disablemask)
	IF NOT disablemask THEN PUT (x, y), graph(img(imgn, mask)), AND
	PUT (x, y), graph(img(imgn, pic)), OR
END SUB

SUB DRAWMAP
CONST cw = 3, ch = 3
CONST mvx = 639 - mazex * cw, mvy = 349 - mazey * ch
	VIEW (mvx, mvy)-(mvx + mazex * cw, mvy + mazey * ch)
	FOR i = 0 TO mazex - 1
		FOR j = 0 TO mazey - 1
			SCANMAZECELL i, j, inner, lw, rw, uw, dw
			col = blackclr
			SELECT CASE inner
				CASE mz.filled: col = goldclr
				CASE mz.half: col = greenclr
				CASE mz.empty: col = blackclr
			END SELECT
			LINE (i * cw + 1, j * ch + 1)-STEP(cw - 2, ch - 2), col, B
			IF uw THEN col = grayclr ELSE col = 0
			LINE (i * cw, j * ch)-STEP(cw, 0), col
			IF dw THEN col = grayclr ELSE col = 0
			LINE (i * cw, j * ch + ch)-STEP(cw, 0), col
			IF lw THEN col = grayclr ELSE col = 0
			LINE (i * cw, j * ch)-STEP(0, ch), col
			IF rw THEN col = grayclr ELSE col = 0
			LINE (i * cw + cw, j * ch)-STEP(0, ch), col
		NEXT
	NEXT
	RESTOREFIELD
END SUB

SUB DRAWPIC (x, y, p AS PICPAR, disablemask)
	IF p.frame >= 0 THEN DRAWIMG x, y, anim(p.mode, img1) + p.frame, disablemask
END SUB

SUB ERASEIMG (x, y, im)
	PUT (x, y), graph(img(im, mask)), AND
END SUB

SUB ERASEPIC (x, y, p AS PICPAR)
	ERASEIMG x, y, anim(p.mode, img1) + p.frame
END SUB

SUB FILLBGR (num)
	n = anim(ani.bgrs, img1) + num
	GETIMAGE n, w, h, idx
	FOR y = 0 TO f.h - 1 STEP h
		FOR x = 0 TO f.w - 1 STEP w
			PUT (x, y), graph(idx), PSET
		NEXT
	NEXT
END SUB

SUB FILLMAZECELL (x, y, i, l, r, u, d)
	IF x < 0 OR y < 0 OR x > mazex - 1 OR y > mazey - 1 THEN EXIT SUB
	x2 = x * 2
	y2 = y * 2
	IF i <> OLD THEN
		SELECT CASE i
			CASE mz.init:   maze(x2, y2) = mz.filled
			CASE mz.filled: IF maze(x2, y2) <> mz.empty AND maze(x2, y2) <> mz.half THEN maze(x2, y2) = i
			CASE mz.half:   IF maze(x2, y2) <> mz.empty THEN maze(x2, y2) = i
			CASE mz.empty:  maze(x2, y2) = i
		END SELECT
	END IF
	IF l <> OLD THEN
		IF x2 <> 0 THEN maze(x2 - 1, y2) = l ELSE maze(x2 - 1, y2) = TRUE
	END IF
	IF r <> OLD THEN
		IF x2 <> (mazex - 1) * 2 THEN maze(x2 + 1, y2) = r ELSE maze(x2 + 1, y2) = TRUE
	END IF
	IF u <> OLD THEN
		IF y2 <> 0 THEN maze(x2, y2 - 1) = u ELSE maze(x2, y2 - 1) = TRUE
	END IF
	IF d <> OLD THEN
		IF y2 <> (mazey - 1) * 2 THEN maze(x2, y2 + 1) = d ELSE maze(x2, y2 + 1) = TRUE
	END IF
	IF mapon THEN DRAWMAP
END SUB

SUB GETCELLCOORDS (x, y, rx, ry)
	rx = x * cellw + viewx
	ry = y * cellh + viewy
END SUB

SUB GETIMAGE (i, x, y, idx)
	idx = img(i, pic)
	DEF SEG = VARSEG(graph(idx))
	x = PEEK(VARPTR(graph(idx)))
	y = PEEK(VARPTR(graph(idx)) + 2)
	DEF SEG
END SUB

SUB GETINPUTS
STATIC cheat$, i$
STATIC tch AS TIMEINT
STATIC tctl AS TIMEINT
	tctl.interval = .045
	tch.interval = 1
	z$ = INKEY$
	IF z$ <> "" THEN i$ = z$
	IF gamestate <> gs.play THEN i$ = ""
	IF z$ = " " THEN
		IF gamestate = gs.play THEN
			gamestate = gs.pause
			WHILE INKEY$ <> "": WEND: WHILE INKEY$ <> " ": WEND
			gamestate = gs.play
		END IF
	ELSE
		SELECT CASE z$
			CASE CHR$(0) + CHR$(68): gamestate = gs.quit: gameresult = gr.abort
			CASE CHR$(0) + CHR$(63): gamestate = gs.newgame
			CASE CHR$(0) + CHR$(62): SCREENSHOT
			CASE CHR$(0) + CHR$(65): noretrace = NOT noretrace
			CASE CHR$(0) + CHR$(83): IF shotc > 0 THEN KILL "dig2ss??.bsv": shotc = 0
		END SELECT
	END IF
	
	IF gamestate = gs.play AND (z$ >= "a" AND z$ <= "z") OR (z$ >= "0" AND z$ <= "9") THEN
		tch.starttime = TIMER
		cheat$ = cheat$ + z$
		SELECT CASE cheat$
			'CASE "aa": CHECKNEWHISCORE 200000: cheat$ = ""
			CASE "mazedebug": mapon = NOT mapon: cheat$ = ""
			CASE "sputterfly":
				COLOR grayclr
				LOCATE 21, 70
				INPUT li
				curlevel = li
				LOADLEVEL li
				cheat$ = ""
				EXIT SUB
			CASE "gridlock": digger.lives = 9: cheat$ = ""
			CASE "frantic": digger.teye.interval = 0: digger.eye = TRUE: cheat$ = ""
			CASE "trace": DRAWMAP: cheat$ = ""
			'CASE "": cheat$ = ""
		END SELECT
	ELSE
		IF z$ <> "" THEN
			cheat$ = ""
		ELSEIF TEVENT(tch) THEN
			cheat$ = ""
		END IF
		IF TEVENT(tctl) AND gamestate = gs.play THEN
			SELECT CASE i$
				CASE CHR$(0) + CHR$(72): MOVEDIGGER 0, -1
				CASE CHR$(0) + CHR$(75): MOVEDIGGER -1, 0
				CASE CHR$(0) + CHR$(80): MOVEDIGGER 0, 1
				CASE CHR$(0) + CHR$(77): MOVEDIGGER 1, 0
				CASE CHR$(0) + CHR$(60): DRAWMAP
				'CASE "+", "=": speed = speed * .9: IF speed < .1 THEN speed = .1
				'CASE "\": speed = 1
				'CASE "-": speed = speed * 1.1: IF speed > 2 THEN speed = 2
				CASE CHR$(0) + CHR$(59), "Z", "z":
					GETMAZECELL digger.x, digger.y, dx, dy
					SCANMAZECELL dx - 1, dy, l, 0, 0, 0, 0
					SCANMAZECELL dx + 1, dy, r, 0, 0, 0, 0
					SCANMAZECELL dx, dy - 1, u, 0, 0, 0, 0
					SCANMAZECELL dx, dy + 1, d, 0, 0, 0, 0
					l = (l = mz.empty)
					d = (d = mz.empty)
					u = (u = mz.empty)
					r = (r = mz.empty)
					IF (digger.mode = dgr.left AND digger.x > imgw AND l) OR (digger.mode = dgr.up AND digger.y > imgh AND u) OR (digger.mode = dgr.right AND digger.x < f.w - imgw * 2 AND r) OR (digger.mode = dgr.down AND digger.y < f.h - imgh * 2 AND d) THEN _

						IF digger.eye THEN
							digger.eye = FALSE
							digger.teye.starttime = TIMER
							SELECT CASE digger.mode
								CASE dgr.left: SHOOT -1, 0
								CASE dgr.right: SHOOT 1, 0
								CASE dgr.up: SHOOT 0, -1
								CASE dgr.down: SHOOT 0, 1
							END SELECT
							ERASEPIC digger.x, digger.y, digger.pic
							digger.pic.mode = digger.pic.mode + anid.withouteye
							DRAWPIC digger.x, digger.y, digger.pic, TRUE
						END IF
					END IF
			END SELECT
			i$ = ""
			IF NOT digger.eye THEN
				IF TEVENT(digger.teye) THEN
					digger.eye = TRUE
					ERASEPIC digger.x, digger.y, digger.pic
					digger.pic.mode = digger.pic.mode - anid.withouteye
					DRAWPIC digger.x, digger.y, digger.pic, TRUE
				END IF
			END IF
		END IF
	END IF
END SUB

FUNCTION GETLEVIDX$ (num)
	IF levelpack$ = "" THEN
		GETLEVIDX$ = levidx(num)
	ELSE
		GETLEVIDX$ = NUMTOSTR$(num + 0)
	END IF
END FUNCTION

SUB GETMAZECELL (x, y, rx, ry)
	IF x - viewx < 0 THEN
		rx = -1
	ELSE
		rx = (x - viewx) \ cellw
	END IF
	IF y - viewy < 0 THEN
		ry = -1
	ELSE
		ry = (y - viewy) \ cellh
	END IF
END SUB

FUNCTION GETPATH (sx, sy, tx, ty, pl) STATIC
CONST x = 0, y = 1, size = mazex * mazey
DIM d(3, 1), wl(3)
DIM mzf(mazex, mazey)
DIM pp(size, 1, 0 TO 1)
DIM bx(20), by(20)

	'SCANMAZECELL tx, ty, v, 0, 0, 0, 0
	'IF v <> mz.empty THEN GETPATH = -1: EXIT FUNCTION

	FOR i = 0 TO mazex - 1
		FOR j = 0 TO mazey - 1
			mzf(i, j) = 0
		NEXT
	NEXT

	dc = 4
	d(0, x) = -1: d(0, y) = 0
	d(1, x) = 1: d(1, y) = 0
	d(2, x) = 0: d(2, y) = -1
	d(3, x) = 0: d(3, y) = 1

	pf = 1
	pp(0, x, 0) = tx
	pp(0, y, 0) = ty
	pc1 = 1
	w = 0
	mzf(tx, ty) = w + 1
	FOR j = 1 TO bagc: GETMAZECELL bag(j).x, bag(j).y, bx(j), by(j): NEXT
	DO
		w = w + 1
		IF pf = 0 THEN
			pf = 1
			pf2 = 0
		ELSE
			pf = 0
			pf2 = 1
		END IF
		pc = pc1
		pc1 = 0
		fw = FALSE
		FOR i = 0 TO pc - 1
			SCANMAZECELL pp(i, x, pf), pp(i, y, pf), 0, wl(0), wl(1), wl(2), wl(3)
			FOR j = 1 TO bagc
				IF bx(j) = pp(i, x, pf) AND by(j) = pp(i, y, pf) THEN
					wl(2) = TRUE
					wl(3) = TRUE
					EXIT FOR
				END IF
			NEXT
			FOR dr = 0 TO dc - 1
				x1 = pp(i, x, pf) + d(dr, x)
				y1 = pp(i, y, pf) + d(dr, y)
				IF x1 >= 0 AND y1 >= 0 AND x1 <= mazex - 1 AND y1 <= mazey - 1 THEN
					IF mzf(x1, y1) = 0 THEN
						SCANMAZECELL x1, y1, v, 0, 0, 0, 0
						IF wl(dr) = FALSE AND v = mz.empty THEN
							IF x1 = sx AND y1 = sy THEN
								SELECT CASE dr
									CASE 0: dirc = 1
									CASE 1: dirc = 0
									CASE 2: dirc = 3
									CASE 3: dirc = 2
								END SELECT
								pl = w
								GETPATH = dirc
								GOTO exitfunc
							END IF
							pp(pc1, x, pf2) = x1
							pp(pc1, y, pf2) = y1
							mzf(x1, y1) = w + 1
							pc1 = pc1 + 1
						END IF
					END IF
				END IF
			NEXT
		NEXT
	LOOP UNTIL pc1 = 0
	pl = -1
	GETPATH = -1
	GOTO exitfunc
exitfunc:
	EXIT FUNCTION
DRW:
CONST cw = 5, ch = 5
CONST mvx = 639 - mazex * cw, mvy = 349 - mazey * ch
	VIEW (mvx, mvy)-(mvx + mazex * cw, mvy + mazey * ch)
	FOR q = 0 TO mazex - 1
		FOR j = 0 TO mazey - 1
			SELECT CASE mzf(q, j)
				CASE IS = 0: col = goldclr
				CASE IS <> 0: col = greenclr
			END SELECT
			LINE (q * cw, j * ch)-STEP(cw, ch), col, BF
		NEXT
	NEXT
	RESTOREFIELD
RETURN
END FUNCTION

SUB GETRANDOMCELL (dx, dy)
	DO
		dx = INT(RND * mazex)
		dy = INT(RND * mazey)
		SCANMAZECELL dx, dy, v, 0, 0, 0, 0
	LOOP UNTIL v = mz.empty
END SUB

FUNCTION IMGSIZE (w, h) STATIC
	size = (4 + INT((w + 7) / 8) * 4 * h - 1) \ 2 + 1
	IMGSIZE = size
END FUNCTION

SUB INIT
	PRINT "Press A to skip keyboard initialization."
	s! = TIMER: DO: LOOP UNTIL s! + .05 <= TIMER
	IF LCASE$(INKEY$) <> "a" THEN
		OUT &H60, &HF3
		s! = TIMER
		DO: LOOP WHILE s! + .3 > TIMER
		OUT &H60, 0
	ELSE
		PRINT "Keyboard initialization skipped."
		DELAY .05
	END IF
	RANDOMIZE TIMER
	SCREEN scrmode
	COLOR 7
	LOADLEVIDX
	LOADGRAPHICS
	LOADSCORES hiscorefile, hiscore()
	SHOWHINTS
' END
END SUB

SUB INITDIGGER
	digger.dx = -1
	digger.pic.mode = ani.dgrleft: digger.mode = dgr.left
	digger.eye = TRUE
	digger.x = digger.startx
	digger.y = digger.starty
END SUB

SUB LOADGRAPHICS
	graphindex = 0
	animc = 0
	RESTORE data.gfx
	FOR i = 1 TO 30
		READ framecount
		anim(animc, framec) = framecount
		anim(animc, img1) = imgc
		animc = animc + 1
		FOR f = 1 TO framecount
			LOADIMAGE w, h, index
		NEXT
	NEXT
	bgrc = anim(ani.bgrs, framec)
	curbgr = -1
	CLS
END SUB

SUB LOADIMAGE (w, h, index)
 
	READ w, h
	FOR y = 0 TO h - 1
		READ B$
		FOR x = 0 TO w - 1
			c = ASC(MID$(B$, x + 1, 1)) - ASC("0")
			c1 = 0
			SELECT CASE c
				CASE 0: c = 0
				CASE 1: c = greenclr
				CASE 2: c = redclr
				CASE 3: c = goldclr
				CASE 4: c = 0: c1 = maxcol
			END SELECT
			PSET (x, y), c
			PSET (x + w, y), c1
		NEXT
	NEXT

	index = imgc

	' save image
	img(imgc, pic) = graphindex
	GET (0, 0)-(w - 1, h - 1), graph(graphindex)
	graphindex = graphindex + IMGSIZE(w, h) * 2

	' save mask
	img(imgc, mask) = graphindex
	GET (0 + w, 0)-(w - 1 + w, h - 1), graph(graphindex)
	graphindex = graphindex + IMGSIZE(w, h) * 2
 
	imgc = imgc + 1
END SUB

SUB LOADLEVEL (levidx AS INTEGER)
	IF NOT OPENLEVEL(GETLEVIDX$(levidx)) THEN
		FOR i = 1 TO digger.lives
			ADDSCORE 1000
		NEXT
		gameresult = gr.winner
		gamestate = gs.quit
	ELSE
		eye.use = FALSE
		x1 = 0
		y1 = 0
		x2 = f.w - 1
		y2 = f.h - 1
		tim.nobbin = tim.s.nobbin - levidx / 2 * tim.d.nobbin: IF tim.nobbin < tim.min.nobbin THEN tim.nobbin = tim.min.nobbin
		tim.hobbin = tim.s.hobbin + levidx * tim.d.hobbin: IF tim.hobbin > tim.max.hobbin THEN tim.hobbin = tim.max.hobbin
		gamestate = gs.play
		bonus.use = FALSE
		emeraldc = 0
		bagc = 0
		goldc = 0
		enemyc = 0
		FOR i = 0 TO mazex - 1
			FOR j = 0 TO mazey - 1
				FILLMAZECELL i, j, mz.init, TRUE, TRUE, TRUE, TRUE
			NEXT
		NEXT
		curbgr = (levidx - 1) MOD bgrc
		FILLBGR curbgr
		bonus.t.starttime = TIMER
		FOR y = 0 TO 9
			s$ = READLEVELSTR$
			IF LEFT$(s$, 1) = "_" THEN
				y = y - 1
				'' script ''
				' no additional commands. '
			ELSE
				'' level_data ''
				FOR x = 0 TO 14
					ch$ = MID$(s$, x + 1, 1)
					SELECT CASE ch$
						CASE "#", " ": FILLMAZECELL x, y, mz.empty, TRUE, TRUE, TRUE, TRUE
						CASE "e":
							nest.x = x
							nest.y = y
							GETCELLCOORDS x, y, bonus.x, bonus.y
							bonus.use = FALSE
							bonus.iwait = levidx * 5 + 30
							bonus.t.interval = bonus.iwait
							bonus.ilen = 20 - levidx: IF bonus.ilen < 3 THEN bonus.ilen = 3
							nest.count = levidx \ 3 + 2: IF nest.count > 5 THEN nest.count = 5
							FILLMAZECELL x, y, mz.empty, TRUE, TRUE, TRUE, TRUE
						CASE "d":
							GETCELLCOORDS x, y, digger.startx, digger.starty
							FILLMAZECELL x, y, mz.empty, FALSE, FALSE, TRUE, TRUE
						CASE "7": ADD newemerald, x, y
						CASE "$": ADD newbag, x, y
					END SELECT
				NEXT
			END IF
		NEXT
		bonusmode = FALSE
		bonusscore = 0
		SETPAL pal.normal
		CLOSELEVEL
		FOR i = 0 TO mazey - 1
			FOR j = 0 TO mazex - 1
				SCANMAZECELL j, i, v, 0, 0, 0, 0
				SCANMAZECELL j - 1, i, l, 0, 0, 0, 0
				SCANMAZECELL j + 1, i, r, 0, 0, 0, 0
				SCANMAZECELL j, i - 1, u, 0, 0, 0, 0
				SCANMAZECELL j, i + 1, d, 0, 0, 0, 0
				IF v = mz.empty THEN
					n = l + r + u + d
					FILLMAZECELL j, i, mz.empty, (l = mz.filled), (r = mz.filled), (u = mz.filled), (d = mz.filled)
					IF r = mz.empty OR l = mz.empty THEN FILLMAZECELL j, i, mz.empty, FALSE, FALSE, OLD, OLD
					IF n < -2 THEN FILLMAZECELL j, i, mz.empty, FALSE, FALSE, FALSE, FALSE
				END IF
			NEXT
		NEXT
		GETMAZECELL digger.startx, digger.starty, cx, cy
		FILLMAZECELL cx, cy, mz.empty, FALSE, FALSE, OLD, OLD
		GETMAZECELL bonus.x, bonus.y, cx, cy
		FILLMAZECELL cx, cy, mz.empty, FALSE, FALSE, OLD, OLD
		FOR i = 0 TO mazey - 1
			FOR j = 0 TO mazex - 1
				SCANMAZECELL j, i, v, 0, 0, 0, 0
				IF v = mz.empty THEN DRAWHOLE j, i
				a$ = INKEY$
			NEXT
		NEXT
		INITDIGGER
	END IF
END SUB

SUB LOADLEVIDX
	RESTORE data.levidx
	READ c
	FOR i = 1 TO c
		READ levidx$(i)
	NEXT
END SUB

SUB LOADSCORES (file$, scorebuf() AS SCORETYPE)
	OPEN hiscorefile$ FOR BINARY AS #1
	FOR i = 0 TO hiscorec - 1
		GET #1, , hiscore(i)
	NEXT
	CLOSE #1
	SHOWHISCORES
END SUB

SUB MOVEBAGS
	FOR i = bagc TO 1 STEP -1
		SELECT CASE bag(i).mode
			CASE bagm.normal
				GETMAZECELL bag(i).x, bag(i).y, mx, my
				SCANMAZECELL mx, my + 1, f, 0, 0, 0, 0
				GETCELLCOORDS mx, my, bx, by
				IF f <> mz.filled AND bag(i).x = bx AND bag(i).y = by THEN
					bag(i).mode = bagm.swinging
					bag(i).misc = 0
					FILLMAZECELL mx, my, mz.empty, OLD, OLD, OLD, FALSE
				END IF
			CASE bagm.swinging
				ERASEPIC bag(i).x, bag(i).y, bag(i).pic
				SELECT CASE bag(i).misc MOD 3
					CASE 0: bag(i).pic.mode = ani.bagleft
					CASE 1: bag(i).pic.mode = ani.bag
					CASE 2: bag(i).pic.mode = ani.bagright
				END SELECT
				bag(i).misc = bag(i).misc + 1
				IF bag(i).misc > 6 THEN
					bag(i).mode = bagm.falling
					bag(i).pic.mode = ani.bagfall
					GETMAZECELL bag(i).x, bag(i).y, 0, bag(i).fally
					FOR B = 0 TO 4: DRAWIMG bag(i).x - 5, bag(i).y + 12 - B * diggerspeedy, iblob.up, FALSE: NEXT
				END IF
				DRAWPIC bag(i).x, bag(i).y, bag(i).pic, TRUE
				REDRAW bag(i).x, bag(i).y, emerald(), emeraldc
			CASE bagm.falling
				'erase bag and dig through soil under it.
				ERASEPIC bag(i).x, bag(i).y, bag(i).pic
				FOR B = 0 TO 2
					DRAWIMG bag(i).x - 5, bag(i).y + 12 - B * diggerspeedy, iblob.up, FALSE
				NEXT

				'move bag
				bag(i).y = bag(i).y + diggerspeedy * 2
				IF BOXCOLL(digger.x, digger.y, imgw, imgh, bag(i).x, bag(i).y, imgw, imgh) THEN
					digger.mode = dgr.falling
					ERASEPIC digger.x, digger.y, digger.pic
					digger.pic.mode = ani.dgrdie
					digger.pic.frame = 0
					digger.x = bag(i).x
					digger.y = bag(i).y
					gamestate = gs.killed
				END IF

				'check for landing
				GETMAZECELL bag(i).x, bag(i).y, bx, by
				SCANMAZECELL bx, by + 1, v, 0, 0, 0, 0
				FILLMAZECELL bx, by, mz.empty, OLD, OLD, 2 * (by = bag(i).fally), 2 * (v = mz.filled)
				f = TRUE
				IF v = mz.filled THEN
					IF digger.x = bag(i).x AND digger.y = bag(i).y THEN
						digger.mode = dgr.dead
					END IF
					IF by - bag(i).fally > 1 THEN
						GETMAZECELL bag(i).x, bag(i).y, x, y
						ADD newgold, x, y
						f = FALSE
					ELSE
						bag(i).mode = bagm.normal
						bag(i).pic.mode = ani.bag
					END IF
				END IF

				'check for enemy killing
				FOR j = 1 TO enemyc
					IF BOXCOLL(bag(i).x, bag(i).y, imgw, imgh, enemy(j).x, enemy(j).y, imgw, imgh) AND enemy(j).mode <> enm.dead THEN
						' if bag is falling, enemy is falling with it, else ...
						IF f AND bag(i).mode <> bagm.normal THEN
							enemy(j).mode = enm.dying
							ERASEPIC enemy(j).x, enemy(j).y, enemy(j).pic
							enemy(j).y = bag(i).y
							enemy(j).x = bag(i).x ' <== if not, enemy can corrupt ground
							IF enemy(j).mode = enm.nobbin THEN
								enemy(j).pic.mode = ani.nobbindie
							ELSEIF enemy(j).mode = enm.hobbin THEN
								enemy(j).pic.mode = enm.nobbin
							END IF
							enemy(j).pic.frame = 0
							DRAWPIC enemy(j).x, enemy(j).y, enemy(j).pic, TRUE
						ELSE
							' ... else enemy is dead
							enemy(j).mode = enm.dead
							enemy(j).tdead.starttime = TIMER: enemy(j).tdead.interval = .5
							ERASEPIC enemy(j).x, enemy(j).y, enemy(j).pic
							enemy(j).y = bag(i).y
						END IF
					END IF
				NEXT

				IF f THEN
					DRAWPIC digger.x, digger.y, digger.pic, TRUE
					DRAWPIC bag(i).x, bag(i).y, bag(i).pic, FALSE
					REDRAW bag(i).x, bag(i).y, emerald(), emeraldc
				ELSE
					SWAP bag(i), bag(bagc)
					bagc = bagc - 1
					MOVEGOLD
				END IF
			CASE bagm.left, bagm.right
				moveit = TRUE
				IF bag(i).mode = bagm.left THEN dx = -diggerspeedx ELSE dx = diggerspeedx
				ERASEPIC bag(i).x, bag(i).y, bag(i).pic

				' if collides to digger or enemy, don't move
				IF BOXCOLL(bag(i).x + dx, bag(i).y, cellw, cellh, digger.x, digger.y, imgw, imgh) AND digger.x * SGN(dx) > (bag(i).x + dx) * SGN(dx) THEN moveit = FALSE
				FOR j = 1 TO enemyc
					IF BOXCOLL(bag(i).x + dx, bag(i).y, cellw, cellh, enemy(j).x, enemy(j).y, imgw, imgh) AND enemy(j).mode <> bagm.dead THEN moveit = FALSE
				NEXT

				IF moveit = TRUE THEN
					IF dx > 0 THEN FOR j = 0 TO 10 STEP diggerspeedx: DRAWIMG bag(i).x - j + 3, bag(i).y - 1, iblob.left, FALSE: NEXT ELSE FOR j = 0 TO 10 STEP diggerspeedx: DRAWIMG bag(i).x + imgw - 8 - j + 3, bag(i).y - 1, iblob.right, FALSE: NEXT
					bag(i).x = bag(i).x + dx

					' check whether shift has been done
					GETMAZECELL bag(i).x, bag(i).y, bgx, bgy
					GETCELLCOORDS bgx, bgy, bgx0, bgy0
					IF bag(i).x = bgx0 THEN
						bag(i).mode = bagm.normal
						bag(i).pic.mode = ani.bag
						SCANMAZECELL bgx, bgy + 1, v, 0, 0, 0, 0
						FILLMAZECELL bgx, bgy, FALSE, (NOT (dx > 0)) * 2, (NOT (dx < 0)) * 2, OLD, OLD
						IF v <> mz.filled THEN
							bag(i).mode = bagm.falling
							bag(i).fally = bgy
						END IF
					END IF
					DRAWPIC bag(i).x, bag(i).y, bag(i).pic, FALSE
					REDRAW bag(i).x - dx, bag(i).y, emerald(), emeraldc
					REDRAW bag(i).x, bag(i).y, emerald(), emeraldc
				ELSE
					IF bag(i).mode = bagm.left THEN
						bag(i).mode = bagm.right
						bag(i).pic.mode = ani.bagright
					ELSE
						bag(i).mode = bagm.left
						bag(i).pic.mode = ani.bagleft
					END IF
					DRAWPIC bag(i).x, bag(i).y, bag(i).pic, FALSE
					REDRAW bag(i).x, bag(i).y, emerald(), emeraldc
				END IF
		END SELECT
	NEXT
END SUB

SUB MOVEDIGGER (dx, dy)
	' *** check for out of bounds *** '
	newx = digger.x + diggerspeedx * dx
	newy = digger.y + diggerspeedy * dy
	GETMAZECELL newx, newy, nx, ny
	GETCELLCOORDS nx, ny, n1x, n1y
	IF nx < 0 OR ny < 0 OR ((nx >= mazex - 1 AND newx <> n1x AND dx > 0) OR (ny >= mazey - 1 AND newy <> n1y AND dy > 0)) THEN EXIT SUB

	' *** adjust for maze cells *** '
	IF ((n1y <> newy AND dx <> 0) OR (n1x <> newx AND dy <> 0)) AND (dx <> digger.dx OR dy <> digger.dy) THEN
		' *** if not in cell, move it in currently used direction
		dx = digger.dx
		dy = digger.dy
		amode = digger.pic.mode
	ELSE
		' *** if in cell, change direction *** '
		IF dx < 0 THEN digger.mode = dgr.left: amode = ani.dgrleft
		IF dx > 0 THEN digger.mode = dgr.right: amode = ani.dgrright
		IF dy < 0 THEN digger.mode = dgr.up: amode = ani.dgrup
		IF dy > 0 THEN digger.mode = dgr.down: amode = ani.dgrdown
		IF NOT digger.eye THEN amode = amode + anid.withouteye
	END IF
 
	' *** calculate new position *** '
	newx = digger.x + diggerspeedx * dx
	newy = digger.y + diggerspeedy * dy

	' *** check gold bags *** '
	IF CHECKBAGSHIFT(newx, newy, dx) THEN EXIT SUB

	digger.dx = dx
	digger.dy = dy
 
	' *** adjust maze *** '
	GETMAZECELL newx - 1, newy, clx, cy
	GETMAZECELL newx, newy - 1, cx, cuy
	GETMAZECELL digger.x - 1, digger.y, olx, oy
	GETMAZECELL digger.x, digger.y - 1, ox, ouy
	IF dx < 0 THEN
		IF clx <> olx THEN FILLMAZECELL clx + 1, cy, mz.empty, FALSE, OLD, OLD, OLD
		SCANMAZECELL clx, cy, v, 0, 0, 0, 0
		FILLMAZECELL clx, cy, (2 * (olx <> clx) + 1) * mz.half * ABS(v), OLD, FALSE, OLD, OLD
	END IF
	IF dx > 0 THEN
		IF ox <> cx THEN FILLMAZECELL cx, cy, mz.empty, OLD, FALSE, OLD, OLD
		SCANMAZECELL cx + 1, cy, v, 0, 0, 0, 0
		FILLMAZECELL cx + 1, cy, (2 * (ox <> cx) + 1) * mz.half * ABS(v), FALSE, OLD, OLD, OLD
	END IF
	IF dy < 0 THEN
		IF cuy <> ouy THEN FILLMAZECELL cx, cuy + 1, mz.empty, OLD, OLD, FALSE, OLD
		SCANMAZECELL cx, cuy, v, 0, 0, 0, 0
		FILLMAZECELL cx, cuy, (2 * (ouy <> cuy) + 1) * mz.half * ABS(v), OLD, OLD, OLD, FALSE
	END IF
	IF dy > 0 THEN
		IF cy <> oy THEN FILLMAZECELL cx, cy, mz.empty, OLD, OLD, OLD, FALSE
		SCANMAZECELL cx, cy + 1, v, 0, 0, 0, 0
		FILLMAZECELL cx, cy + 1, (2 * (oy <> cy) + 1) * mz.half * ABS(v), OLD, OLD, FALSE, OLD
	END IF
	'DRAWMAZE

	' *** dig through the ground *** '
	SELECT CASE digger.mode
		CASE dgr.left: DRAWIMG newx - 5, newy - 1, iblob.left, FALSE
		CASE dgr.right: DRAWIMG newx + 10 + 1, newy - 1, iblob.right, FALSE
		CASE dgr.up: DRAWIMG newx - 5, newy - 3, iblob.up, FALSE
		CASE dgr.down: DRAWIMG newx - 5, newy + 12, iblob.down, FALSE
	END SELECT


	'redraw sprite
	RETRACE
	ERASEPIC digger.x, digger.y, digger.pic
	digger.x = newx
	digger.y = newy
	digger.pic.mode = amode
	DRAWPIC digger.x, digger.y, digger.pic, TRUE
END SUB

SUB MOVEENEMIES
DIM w(3)
DIM delta(3, 1)
CONST xd = 0, yd = 1
	delta(0, xd) = -1
	delta(1, xd) = 1
	delta(2, yd) = -1
	delta(3, yd) = 1
	'RETRACE
	FOR i = enemyc TO 1 STEP -1
		IF (enemy(i).stpx = enemy(i).x AND enemy(i).stpy = enemy(i).y) AND gamestate = gs.play AND enemy(i).mode <> enm.dying THEN
			IF TEVENT(enemy(i).thob) THEN
				enemy(i).thob.starttime = TIMER
				IF NOT bonusmode THEN
					IF enemy(i).mode = enm.nobbin THEN
						ERASEPIC enemy(i).x, enemy(i).y, enemy(i).pic
						enemy(i).pic.mode = ani.hobbinleft
						enemy(i).pic.frame = 0
						enemy(i).mode = enm.hobbin
						enemy(i).chaseflee = TRUE
						enemy(i).thob.interval = tim.hobbin
					ELSE
						ERASEPIC enemy(i).x, enemy(i).y, enemy(i).pic
						enemy(i).pic.mode = ani.nobbin
						enemy(i).pic.frame = 0
						enemy(i).mode = enm.nobbin
						enemy(i).thob.interval = tim.nobbin
					END IF
				END IF
			END IF
			GETMAZECELL enemy(i).x, enemy(i).y, cx, cy
			IF enemy(i).mode = enm.nobbin THEN
				IF INT(RND * 1000) < 70 OR (cx = enemy(i).trgx AND cy = enemy(i).trgy) OR enemy(i).chaseflee = TRUE THEN
					IF INT(RND * 100) < (20 + 15 * (enemy(i).chaseflee = TRUE)) AND NOT bonusmode THEN
						enemy(i).chaseflee = FALSE
						GETRANDOMCELL dx, dy
						enemy(i).trgx = dx
						enemy(i).trgy = dy
					ELSE
						enemy(i).chaseflee = TRUE
						GETMAZECELL digger.x, digger.y, dx, dy
						IF bonusmode THEN
							temp = GETPATH(cx, cy, dx, dy, pl0)
							IF pl0 <> -1 THEN
								SCANMAZECELL cx, cy, 0, w(0), w(1), w(2), w(3)
								f = FALSE
								DO
									FOR j = 0 TO 3
										IF w(j) = FALSE THEN
											SCANMAZECELL cx + delta(j, xd), cy + delta(j, yd), v, 0, 0, 0, 0
											IF v = mz.empty THEN
												temp = GETPATH(dx, dy, cx + delta(j, xd), cy + delta(j, yd), pl)
												IF pl > pl0 THEN
													IF INT(RND * 3) = 0 THEN
														dx = cx + delta(j, xd)
														dy = cy + delta(j, yd)
														EXIT DO
													END IF
													f = TRUE
												END IF
											END IF
										END IF
									NEXT ' j
									IF NOT f THEN
										enemy(i).trgx = cx
										enemy(i).trgy = cy
										EXIT DO
									END IF
								LOOP
							ELSE
								GETRANDOMCELL dx, dy
								enemy(i).trgx = dx
								enemy(i).trgy = dy
								enemy(i).chaseflee = FALSE
							END IF
						ELSE
							enemy(i).chaseflee = TRUE
						END IF
					END IF
				END IF
				FILLMAZECELL cx, cy, mz.empty, OLD, OLD, OLD, OLD
				SCANMAZECELL dx, dy, v, 0, 0, 0, 0
				DO
					IF enemy(i).chaseflee = TRUE THEN
						IF v <> mz.empty THEN
							IF digger.dx <> 0 THEN
								dx = dx + 1
							ELSEIF digger.dy <> 0 THEN
								dy = dy + 1
							END IF
						END IF
							
						r = GETPATH(cx, cy, dx, dy, 0)
						enemy(i).trgx = dx
						enemy(i).trgy = dy
					ELSE
						r = GETPATH(cx, cy, enemy(i).trgx, enemy(i).trgy, 0)
					END IF
					IF r = -1 THEN
						GETRANDOMCELL dx, dy
						enemy(i).chaseflee = FALSE
						enemy(i).trgx = dx
						enemy(i).trgy = dy
					ELSE
						EXIT DO
					END IF
				LOOP
				SELECT CASE r
					CASE 0: cx = cx - 1
					CASE 1: cx = cx + 1
					CASE 2: cy = cy - 1
					CASE 3: cy = cy + 1
				END SELECT
			ELSEIF enemy(i).mode = enm.hobbin THEN ' it's hobbin
				d = enemy(i).dir
				FILLMAZECELL cx, cy, FALSE, (d <> 1) * 2, (d <> 2) * 2, (d <> 3) * 2, (d <> 4) * 2
				DO
					enemy(i).chaseflee = INT(RND * 200) < 20 - 160 * enemy(i).chaseflee
					IF enemy(i).chaseflee = TRUE THEN
						rx = ABS(digger.x - enemy(i).x)
						ry = ABS(digger.y - enemy(i).y)
						btime! = TIMER
						DO
							enemy(i).dir = INT(RND * 4) + 1
							SELECT CASE enemy(i).dir
								CASE 1, 2:
									IF NOT ((enemy(i).dir = 1 AND cx = 0) OR (enemy(i).dir = 2 AND cx = mazex - 1)) THEN
										IF (ABS(digger.x - (enemy(i).x - ((enemy(i).dir = 2) * 2 + 1) * diggerspeedx)) - rx) * SGN(bonusmode * 2 + 1) < 0 THEN EXIT DO
									END IF
								CASE 3, 4:
									IF NOT ((enemy(i).dir = 3 AND cy = 0) OR (enemy(i).dir = 4 AND cy = mazey - 1)) THEN
										IF (ABS(digger.y - (enemy(i).y - ((enemy(i).dir = 4) * 2 + 1) * diggerspeedy)) - ry) * SGN(bonusmode * 2 + 1) < 0 THEN EXIT DO
									END IF
							END SELECT
							IF btime! + .1 < TIMER THEN
								enemy(i).chaseflee = FALSE
								EXIT DO
							END IF
						LOOP
					ELSE
						IF enemy(i).dir = 0 OR INT(RND * 5) = 2 THEN enemy(i).dir = INT(RND * 4) + 1
					END IF
					SELECT CASE enemy(i).dir
						CASE 1: IF cx = 0 THEN enemy(i).dir = 0 ELSE cx = cx - 1
						CASE 2: IF cx = mazex - 1 THEN enemy(i).dir = 0 ELSE cx = cx + 1
						CASE 3: IF cy = 0 THEN enemy(i).dir = 0 ELSE cy = cy - 1
						CASE 4: IF cy = mazey - 1 THEN enemy(i).dir = 0 ELSE cy = cy + 1
					END SELECT
					d = enemy(i).dir
					FILLMAZECELL cx, cy, OLD, (d <> 2) * 2, (d <> 1) * 2, (d <> 4) * 2, (d <> 3) * 2
				LOOP UNTIL enemy(i).dir <> 0
			END IF
			GETCELLCOORDS cx, cy, enemy(i).stpx, enemy(i).stpy
		END IF
		IF enemy(i).mode = enm.dead THEN
			IF TEVENT(enemy(i).tdead) THEN
				ERASEPIC enemy(i).x, enemy(i).y, enemy(i).pic
				REDRAWOBJS gold(), goldc, FALSE
				REDRAWOBJS bag(), bagc, FALSE
				SWAP enemy(i), enemy(enemyc)
				enemyc = enemyc - 1
				ADDSCORE 250
			ELSE
				DRAWPIC enemy(i).x, enemy(i).y, enemy(i).pic, FALSE
				REDRAWOBJS gold(), goldc, FALSE
			END IF
		ELSE
			IF enemy(i).mode <> enm.dying AND enemy(i).mode <> enm.dead THEN
				nx = enemy(i).x + diggerspeedx * SGN(enemy(i).stpx - enemy(i).x)
				ny = enemy(i).y + diggerspeedy * SGN(enemy(i).stpy - enemy(i).y)
				ERASEPIC enemy(i).x - 1, enemy(i).y, enemy(i).pic
				IF enemy(i).mode = enm.hobbin OR NOT CHECKBAGSHIFT(nx, ny, SGN(enemy(i).stpx - enemy(i).x)) THEN
					IF enemy(i).mode = enm.hobbin THEN
						FOR j = bagc TO 1 STEP -1
							IF BOXCOLL(nx, ny, imgw, imgh, bag(j).x + 1, bag(j).y + 1, imgw - 2, imgh - 2) THEN
								ERASEPIC bag(j).x, bag(j).y, bag(j).pic
								SWAP bag(bagc), bag(j)
								bagc = bagc - 1
							END IF
						NEXT
						SELECT CASE enemy(i).dir
							CASE 1: DRAWIMG nx - 5, ny - 1, iblob.left, FALSE
							CASE 2: DRAWIMG nx + 10 + 1, ny - 1, iblob.right, FALSE
							CASE 3: DRAWIMG nx - 5, ny - 3, iblob.up, FALSE
							CASE 4: DRAWIMG nx - 5, ny + 12, iblob.down, FALSE
						END SELECT
						IF nx < enemy(i).x THEN enemy(i).pic.mode = ani.hobbinleft
						IF nx > enemy(i).x THEN enemy(i).pic.mode = ani.hobbinright
					END IF
					CHECKGOLD nx, ny, FALSE
					CHECKEMERALDS nx, ny, FALSE
					enemy(i).x = nx
					enemy(i).y = ny
					ANIMATE enemy(i).x, enemy(i).y, enemy(i).pic, FALSE
				END IF
				DRAWPIC enemy(i).x - 1, enemy(i).y, enemy(i).pic, FALSE
			END IF
		END IF
	NEXT
END SUB

SUB MOVEEYE
	ERASEPIC eye.x, eye.y, eye.pic
	REDRAW eye.x, eye.y, bag(), bagc
	REDRAW eye.x, eye.y, emerald(), emeraldc
	REDRAW eye.x, eye.y, gold(), goldc
	ANIMATE eye.x, eye.y, eye.pic, FALSE
	IF eye.mode = eyem.normal THEN
		eye.x = eye.x + eye.dx * diggerspeedx * 2
		eye.y = eye.y + eye.dy * diggerspeedy * 2
		FOR i = enemyc TO 1 STEP -1
			IF BOXCOLL(enemy(i).x, enemy(i).y, imgw, imgh, eye.x, eye.y, eyew, eyeh) THEN
				ERASEPIC enemy(i).x - 1, enemy(i).y, enemy(i).pic
				eye.pic.mode = ani.expl
				eye.pic.frame = 0
				eye.mode = eyem.expl
				ADDSCORE 250
				SWAP enemy(i), enemy(enemyc)
				enemyc = enemyc - 1
				EXIT FOR
			END IF
		NEXT
		GETMAZECELL eye.x - (eye.dx > 0) * (diggerspeedx + eyew), eye.y - (eye.dy > 0) * (diggerspeedy + eyeh), x, y
		SCANMAZECELL x, y, i, 0, 0, 0, 0
		IF i = mz.filled THEN
			eye.pic.mode = ani.expl
			eye.pic.frame = 0
			eye.mode = eyem.expl
		END IF
	ELSE
		IF eye.pic.frame = anim(ani.expl, framec) - 1 THEN eye.use = FALSE
	END IF
	IF eye.use THEN DRAWPIC eye.x, eye.y, eye.pic, FALSE
END SUB

SUB MOVEGOLD
	FOR i = goldc TO 1 STEP -1
		IF gold(i).pic.frame <> 2 THEN
			ANIMATE gold(i).x, gold(i).y, gold(i).pic, TRUE
			REDRAW gold(i).x, gold(i).y, emerald(), emeraldc
			REDRAW gold(i).x, gold(i).y, bag(), bagc
		END IF
		GETMAZECELL gold(i).x, gold(i).y, x, y
		SCANMAZECELL x, y + 1, v, 0, 0, 0, 0
		IF v <> mz.filled THEN gold(i).t.interval = 5
		IF TEVENT(gold(i).t) THEN
			ERASEPIC gold(i).x, gold(i).y, gold(i).pic
			REDRAW gold(i).x, gold(i).y, emerald(), emeraldc
			REDRAW gold(i).x, gold(i).y, bag(), bagc
			SWAP gold(i), gold(goldc)
			goldc = goldc - 1
		END IF
	NEXT
END SUB

SUB NEWGAME
DIM tbags AS TIMEINT
DIM tstat AS TIMEINT
DIM tdgra AS TIMEINT
DIM tgold AS TIMEINT
DIM tbon AS TIMEINT
DIM tenem AS TIMEINT
DIM teani AS TIMEINT
DIM tenew AS TIMEINT
	RESTOREFIELD
	gameresult = 0
	tbon.interval = .1
	tbags.interval = .1
	tstat.interval = .05
	tdgra.interval = .08
	tgold.interval = .1
	tcons.interval = 1
	tenem.interval = .045
	teani.interval = .1
	tenew.interval = 3
	tim.eye = 1
	digger.lives = 4
	digger.score = 0
	digger.teye.interval = tim.eye
	NEXTLEVEL
	DO
		ADDSCORE 0

		GETINPUTS
		IF gamestate = gs.newgame OR gamestate = gs.quit THEN EXIT SUB

		IF gamestate <> gs.killed THEN
			' next level if all emeralds collected
			IF emeraldc = 0 THEN
				NEXTLEVEL
				IF gamestate = gs.quit THEN EXIT SUB
			END IF
			IF bonusmode THEN     '  <==  flash palette if bonus ends
				s! = (bonus.t.interval - (TIMER - bonus.t.starttime)) * 2
				IF s! < 9 AND ABS(INT(s!) - s!) < .2 THEN SETPAL s! MOD 2
			END IF
			IF TEVENT(tenew) THEN '  <==  create new enemy if not in bonus
				IF enemyc < nest.count AND NOT bonusmode THEN ADD newnobbin, nest.x, nest.y
			END IF
			tenem.interval = .045 * speed ' adjust game speed
			CHECKGOLD digger.x, digger.y, TRUE

			' etc. '
			IF TEVENT(tenem) THEN ' move enemies, eye and check for enemy kills
				MOVEENEMIES
				IF eye.use THEN MOVEEYE
				CHECKKILL
			END IF
			IF TEVENT(bonus.t) THEN ' <== switch bonus
				IF bonusmode THEN
					bonusmode = FALSE
					SETPAL pal.normal
					bonus.t.starttime = TIMER
					bonus.iwait = bonus.iwait + 5
					bonus.t.interval = bonus.iwait
				ELSE
					bonus.t.interval = bonus.ilen
					bonus.t.starttime = TIMER
					bonus.use = TRUE
				END IF
			END IF
			IF TEVENT(tbon) THEN CHECKBONUS digger.x, digger.y, TRUE
			IF TEVENT(tcons) THEN consemer = 0  ' <== remove emerald octave
		ELSE
			tdgra.interval = .14
			IF digger.pic.frame = anim(ani.dgrdie, framec) - 1 THEN
				IF NOT RESTART THEN EXIT SUB
				tdgra.interval = .08
			END IF
		END IF
		CHECKEMERALDS digger.x, digger.y, TRUE
		IF TEVENT(tgold) THEN MOVEGOLD: IF gamestate <> gs.play THEN DRAWPIC digger.x, digger.y, digger.pic, FALSE
		IF TEVENT(tbags) THEN MOVEBAGS
		IF TEVENT(tstat) THEN
			SHOWSCORE digger.score, digger.lives
		END IF
		IF TEVENT(tdgra) AND digger.mode <> dgr.falling THEN
			RETRACE
			ANIMATE digger.x, digger.y, digger.pic, TRUE
		END IF
	LOOP
END SUB

SUB NEXTLEVEL
	curlevel = curlevel + 1
	LOADLEVEL curlevel
END SUB

FUNCTION NUMTOSTR$ (n AS LONG)
	NUMTOSTR = LTRIM$(RTRIM$(STR$(n)))
END FUNCTION

FUNCTION OPENLEVEL (idx$)
	IF levelpack$ = "" THEN
		RESTORE data.levels
		DO
			READ s$
			s$ = LTRIM$(RTRIM$(s$))
			IF s$ = "_end" THEN
				OPENLEVEL = FALSE
				EXIT FUNCTION
			END IF
		LOOP UNTIL s$ = "_mine #" + idx$
		OPENLEVEL = TRUE
	ELSE
		'read from file
		OPEN levelpack$ FOR INPUT AS #1
		DO
			LINE INPUT #1, s$
			s$ = LTRIM$(RTRIM$(s$))
			IF s$ = "_end" THEN
				OPENLEVEL = FALSE
				CLOSE #1
				EXIT FUNCTION
			END IF
		LOOP UNTIL s$ = "_mine #" + idx$
		OPENLEVEL = TRUE
	END IF
END FUNCTION

SUB QUIT
	SCREEN 0
	WIDTH 80, 25
	ERASE img
	ERASE gold
	ERASE bag
	ERASE emerald
	ERASE graph
	ERASE anim
	PRINT "QDigger v1.4b EGA, 2002-2008"
	PRINT "Thank you for playing!"
	PRINT
	END
END SUB

FUNCTION READLEVELSTR$
	IF levelpack$ = "" THEN
		READ s$
		READLEVELSTR$ = s$
	ELSE
		LINE INPUT #1, s$
		READLEVELSTR$ = s$
	END IF
END FUNCTION

SUB REDRAW (x, y, obj() AS PICKUPTYPE, objc)
	FOR j = 1 TO objc
		IF BOXCOLL(x, y, cellw, cellh, obj(j).x, obj(j).y, imgw, imgh) THEN
			DRAWPIC obj(j).x, obj(j).y, obj(j).pic, FALSE
			EXIT SUB
		END IF
	NEXT
END SUB

SUB REDRAWOBJS (arr() AS PICKUPTYPE, n, maskfl)
	RETRACE
	FOR i = 1 TO n
		DRAWPIC arr(i).x, arr(i).y, arr(i).pic, NOT maskfl
	NEXT
END SUB

FUNCTION RESTART
	DELAY 1
	WHILE INKEY$ <> "": WEND
	digger.lives = digger.lives - 1
	IF digger.lives < 0 THEN
		digger.lives = 0
		RESTART = FALSE
		gameresult = gr.gameover
		EXIT FUNCTION
	END IF
	IF bonus.use = FALSE THEN bonus.t.starttime = TIMER
	FOR i = 1 TO enemyc
		ERASEPIC enemy(i).x, enemy(i).y, enemy(i).pic
	NEXT
	FOR i = bagc TO 1 STEP -1
		IF bag(i).mode = bagm.falling THEN
			ERASEPIC bag(i).x, bag(i).y, bag(i).pic
			SWAP bag(i), bag(bagc)
			bagc = bagc - 1
		END IF
	NEXT
	enemyc = 0
	IF eye.use THEN
		ERASEPIC eye.x, eye.y, eye.pic
		eye.use = FALSE
	END IF
	ERASEPIC digger.x, digger.y, digger.pic
	INITDIGGER
	gamestate = gs.play
	WHILE LEN(INKEY$) <> 0: WEND
	REDRAWOBJS emerald(), emeraldc, TRUE
	WHILE LEN(INKEY$) <> 0: WEND
	REDRAWOBJS gold(), goldc, TRUE
	WHILE LEN(INKEY$) <> 0: WEND
	REDRAWOBJS bag(), bagc, TRUE
	WHILE LEN(INKEY$) <> 0: WEND
	RESTART = TRUE
END FUNCTION

SUB RESTOREFIELD
	VIEW (f.x, f.y)-(f.x + f.w - 1, f.y + f.h - 1)
END SUB

SUB RETRACE
	IF NOT noretrace THEN
		WAIT &H3DA, 8
	END IF
END SUB

SUB SCANMAZECELL (cx, cy, inner, lw, rw, uw, dw)
	cx2 = cx * 2
	cy2 = cy * 2
	IF cx < 0 OR cy < 0 OR cx > mazex - 1 OR cy > mazey - 1 THEN
		inner = mz.filled
		lw = TRUE
		rw = TRUE
		uw = TRUE
		dw = TRUE
	ELSE
		inner = maze(cx2, cy2)
		lw = maze(cx2 - 1, cy2)
		rw = maze(cx2 + 1, cy2)
		uw = maze(cx2, cy2 - 1)
		dw = maze(cx2, cy2 + 1)
	END IF
END SUB

SUB SCREENSHOT
	a$ = NUMTOSTR$(shotc + 0)
	a$ = STRING$(2 - LEN(a$), "0") + a$
	shotc = (shotc + 1) MOD 100

	siz = IMGSIZE(f.w, f.h) + 1
	DIM buf(siz) AS INTEGER

	buf(0) = bonusmode

	GET (0, 0)-(f.w - 1, f.h - 1), buf(1)
	LINE (0, 0)-STEP(f.w, f.h), blackclr, BF
	DEF SEG = VARSEG(buf(1))
	BSAVE "dig2ss" + a$ + ".bsv", VARPTR(buf(0)), siz * 2
	DEF SEG

	WHILE LEN(INKEY$) <> 0: WEND
	PUT (0, 0), buf(1), PSET
	ERASE buf
END SUB

SUB SETPAL (palmode AS INTEGER)
	IF nopal OR scrmode = 12 THEN EXIT SUB
	RETRACE
	SELECT CASE palmode
		CASE pal.loading
			PALETTE greenclr, 0
			PALETTE redclr, 0
			PALETTE goldclr, 0
			PALETTE 15, 0
		CASE pal.normal
			PALETTE greenclr, 2
			PALETTE redclr, 4
			PALETTE goldclr, 4 + 16
		CASE pal.bonus
			PALETTE greenclr, 18
			PALETTE redclr, 52
			PALETTE goldclr, 38
	END SELECT
END SUB

'
' this function checks whether bag #num can be moved in (dir) direction.
' can't move (FALSE) if:
'   bag's direction (dir) = 0
'   bag is on the end of the maze
'   bag collides with the digger or with an enemy
' else
'   accept (TRUE); change bag mode and params
'
FUNCTION SHIFTBAG (num, dir)
	IF dir = 0 THEN SHIFTBAG = FALSE: EXIT FUNCTION

	GETMAZECELL bag(num).x, bag(num).y, bx, by
	IF bx = 0 OR bx = mazex - 1 THEN SHIFTBAG = FALSE: EXIT FUNCTION

	IF BOXCOLL(bag(num).x + dir, bag(num).y, cellw, cellh, digger.x, digger.y, imgw, imgh) THEN SHIFTBAG = FALSE: EXIT FUNCTION
	FOR i = 1 TO bagc
		IF i <> num THEN
			IF BOXCOLL(bag(num).x + dir, bag(num).y, cellw, cellh, bag(i).x, bag(i).y, cellw - 1, imgh) AND bag(i).mode = bagm.normal AND bag(num).x * SGN(dir) < bag(i).x * SGN(dir) THEN
				IF SHIFTBAG(i, dir) = FALSE THEN SHIFTBAG = FALSE: EXIT FUNCTION
			END IF
		END IF
	NEXT

	SHIFTBAG = TRUE
	GETMAZECELL bag(num).x, bag(num).y, cx, cy
	FILLMAZECELL cx, cy, FALSE, OLD, OLD, OLD, OLD
	IF dir < 0 THEN
		bag(num).mode = bagm.left
		bag(num).pic.mode = ani.bagleft
		GETCELLCOORDS bx, by, x, y
		IF x = bag(num).x AND y = bag(num).y THEN d = 1 ELSE d = 0
		GETCELLCOORDS bx - d, by, bag(num).dx, 0
	ELSE
		bag(num).mode = bagm.right
		bag(num).pic.mode = ani.bagright
		GETCELLCOORDS bx + 1, by, bag(num).dx, 0
	END IF
END FUNCTION

SUB SHOOT (dx, dy)
	IF eye.use THEN EXIT SUB
	eye.x = digger.x - 5 * (dx = 0 AND dy < 0) - imgw * (dx > 0) + eyew * (dx < 0)
	eye.y = digger.y - 2 * (dy = 0) - imgh * (dy > 0) + eyeh * (dy < 0)
	eye.dx = dx
	eye.dy = dy
	eye.use = TRUE
	eye.mode = eyem.normal
	eye.pic.mode = ani.fire
	eye.pic.frame = 0
END SUB

SUB SHOWHINT (col, row, a$)
CONST charw = 8, charh = 14 '- 2 * (scrmode = 12)
	cl = grayclr
	x = col
	LOCATE row, col
	FOR i = 1 TO LEN(a$)
		COLOR cl: f = 0
		SELECT CASE MID$(a$, i, 1)
			CASE "*": PRINT CHR$(4); : x = x + 1
			CASE "\": IF cl = grayclr THEN cl = greenclr ELSE cl = grayclr
			CASE "&":
				SELECT CASE MID$(a$, i + 1, 1)
					CASE "e": im = 61: dx = -4: dy = 2: f = 1
					CASE "g": im = 63: dy = -1: ' dx = 6
					CASE "c": im = 66
					CASE "n": im = 49
					CASE "h": im = 57
					CASE "s": im = 73: f = 1: dx = 0: dy = 3
				END SELECT
				IF f = 0 THEN PRINT "  ";  ELSE PRINT " ";
				x = x + 1
				DRAWIMG charw * (x - 2) + dx, (row - 1) * charh + dy, im, TRUE
				IF f = 0 THEN x = x + 1
				i = i + 1
			CASE ELSE: PRINT MID$(a$, i, 1); : x = x + 1
		END SELECT
	NEXT
END SUB

SUB SHOWHINTS
	VIEW
	col = 4: ctl = 45
	SHOWHINT 2, 17, "The scoring system works as follows:"
	SHOWHINT col, 19, "* Emerald (&e): \25\ points."
	SHOWHINT col, 20, "* Eight consecutive emeralds (octave): Extra \250\ points."
	SHOWHINT col, 21, "* Gold (&g): \500\ points."
	SHOWHINT col, 22, "* Killing a Nobbin (&n) or a Hobbin (&h) by shooting (&s) or"
	SHOWHINT col, 23, "  hitting with a bag (&g): \250\ points."
	SHOWHINT col, 24, "* Bonus (&c): \1,000\ points; extra life: \5,000\ points."
	SHOWHINT ctl, 1, "use arrow keys to move,"
	SHOWHINT ctl, 2, "F1/Z to shoot, space"
	SHOWHINT ctl, 3, "to pause, and +/- to"
	SHOWHINT ctl, 4, "increase/decrease speed"
	RESTOREFIELD
END SUB

SUB SHOWHISCORES
	VIEW
	COLOR goldclr
	LOCATE scores.y - 2, scores.x + 4: PRINT "HIGH SCORES";
	FOR i = 0 TO hiscorec - 1
		COLOR grayclr
		FOR j = 1 TO namelen
			IF INSTR(CHR$(0), MID$(hiscore(i).uname, j, 1)) <> 0 THEN MID$(hiscore(i).uname, j, 1) = "."
		NEXT
		LOCATE scores.y + i, scores.x: PRINT hiscore(i).uname;
		a$ = NUMTOSTR$(hiscore(i).score)
		COLOR redclr
		LOCATE scores.y + i, scores.x + namelen + 1: PRINT a$;
	NEXT
	RESTOREFIELD
END SUB

SUB SHOWSCORE (score AS LONG, lives AS INTEGER)
DIM ind(1 TO 8) AS INTEGER
DIM im(0 TO 10, 0 TO 2) AS INTEGER
 
	a$ = LTRIM$(RTRIM$(STR$(score)))
	a$ = STRING$(7 - LEN(a$), "0") + a$
	FOR i = 1 TO LEN(a$)
		ind(i) = ASC(MID$(a$, i, 1)) - ASC("0") + img0
	NEXT
	indc = LEN(a$)

	FOR i = 0 TO 10
		GETIMAGE anim(ani.stat, img1) + i, im(i, 1), im(i, 2), im(i, 0)
	NEXT

	VIEW (0, 0)-(f.w + f.x, 14)
	x = f.x
	FOR i = 1 TO indc
		PUT (x, 0), graph(im(ind(i), 0)), PSET
		x = x + im(ind(i), 1) + 3
	NEXT
	VIEW (7 * 15 + f.x + 2, 0)-(7 * 15 + f.x + 2 + f.w, 14)
	GETIMAGE anim(ani.stat, img1) + 10, w, 0, idx
	FOR i = 0 TO lives - 1
		PUT (i * (w + 5), 1), graph(idx), PSET
	NEXT
	LINE (lives * (w + 5), 1)-STEP(w * 2, 14), 0, BF
	RESTOREFIELD
END SUB

FUNCTION TEVENT (t AS TIMEINT)
DIM tmr AS SINGLE
	tmr = TIMER
	IF tmr >= t.starttime + t.interval OR ABS(tmr - t.starttime) > 10000 THEN
		t.starttime = TIMER
		TEVENT = TRUE
	ELSE
		TEVENT = FALSE
	END IF
END FUNCTION

SUB UPDATESCORES
	OPEN hiscorefile$ FOR BINARY ACCESS WRITE AS #1
	SEEK #1, 1
	FOR i = 0 TO hiscorec - 1
		PUT #1, , hiscore(i)
	NEXT
	CLOSE #1
	LOADSCORES hiscorefile, hiscore()
END SUB

